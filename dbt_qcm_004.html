<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dbt QCM - Fondamentaux</title>
   


   <style>
        :root {
            --bg: #0d1117; 
            --card: #161b22; 
            --txt: #c9d1d9; 
            --border: #30363d;
            --level-green: #2ea043;
            --level-orange: #f0883e;
            --level-red: #ff4500;
            --cmd-main: #2ea043;
            --cmd-args: #58a6ff;
            --hl-red: #ff7b72;
            --green-ans: #238636;
        }

        body {
            font-family: -apple-system, system-ui, sans-serif;
            background: var(--bg); color: var(--txt); line-height: 1.4; 
            margin: 0; display: flex; /* Layout en deux colonnes */
        }

        /* --- SIDEBAR MENU --- */
        .sidebar {
            width: 300px;
            background: var(--card);
            border-right: 1px solid var(--border);
            padding: 20px;
            height: 100vh;
            position: sticky;
            top: 0;
            box-sizing: border-box;
            overflow-y: auto;
        }

        .sidebar h2 { color: var(--level-red); font-size: 1.1rem; margin-bottom: 20px; text-align: center; }

        .menu-item {
            display: block;
            padding: 10px 15px;
            margin-bottom: 8px;
            background: #21262d;
            color: var(--txt);
            text-decoration: none;
            border-radius: 6px;
            border: 1px solid var(--border);
            font-size: 0.9rem;
            transition: 0.2s;
        }

        .menu-item:hover { background: #30363d; transform: translateX(5px); border-color: #8b949e; }

        .sub-menu {
            display: flex;
            flex-direction: column;
            margin-left: 15px;
            padding-left: 10px;
            border-left: 2px solid var(--border);
            margin-bottom: 15px;
        }

        .sub-item { font-size: 0.8rem !important; padding: 8px 10px !important; margin: 2px 0 !important; }

        .active-page {
            border-color: var(--level-orange) !important;
            color: var(--level-orange) !important;
            background: rgba(240, 136, 62, 0.1) !important;
            font-weight: bold;
        }

        summary { list-style: none; outline: none; }
        summary::-webkit-details-marker { display: none; }

        /* --- CONTENU QCM --- */
        .container { flex: 1; max-width: 800px; margin: 0 auto; padding: 30px; }

        h1 { text-align: center; color: var(--level-red); font-size: 1.8rem; margin-bottom: 20px; }

        .intro { 
            background: var(--card); padding: 12px; border-radius: 6px; border: 1px solid var(--level-red);
            margin-bottom: 25px; font-size: 0.9rem; text-align: center;
        }

        .q-card { 
            background: var(--card); border: 1px solid var(--border); border-radius: 12px; 
            padding: 20px; margin-bottom: 20px; 
        }

.q-head, .q-head_orange, .q-head_green, .q-head_red {
    font-weight: bold;
    font-size: 0.85rem;
    display: block;
    text-transform: uppercase;
    margin-bottom: 10px;
    padding: 6px 12px;
    background: rgba(33, 38, 45, 0.8);
    border-radius: 6px;
    display: inline-block;
    border-left: 4px solid;
}

.q-head { 
    color: var(--level-red);
    border-left-color: var(--level-red);
}

.q-head_orange { 
    color: var(--level-orange);
    border-left-color: var(--level-orange);
}

.q-head_green { 
    color: var(--level-green);
    border-left-color: var(--level-green);
}

.q-head_red { 
    color: #ff6b6b; /* Rouge vif */
    border-left-color: #ff6b6b;
    background: rgba(255, 107, 107, 0.1);
}

        .q-txt { font-weight: 600; margin-bottom: 15px; display: block; font-size: 1.1rem; }
        .opt { background: #21262d; padding: 12px; margin: 8px 0; border-radius: 6px; font-size: 0.95rem; border: 1px solid transparent; }
        
        code { background: #000; padding: 2px 5px; border-radius: 4px; font-family: monospace; color: var(--txt); }
		
		code {
    background: linear-gradient(145deg, 
        #1a1f26,  /* Gris fonc√© bleut√© */
        #161b22   /* Gris encore plus fonc√© */
    );
    padding: 2px 8px;
    border-radius: 6px;
    font-family: 'Monaco', 'Menlo', 'Consolas', 'Roboto Mono', monospace;
    color: var(--txt); /* #c9d1d9 (gris clair) selon ta variable */
    border: 1px solid var(--border); /* #30363d (gris bordure) selon ta variable */
    font-size: 0.9em;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Ombre noire √† 20% d'opacit√© */
    transition: all 0.2s ease;
}
		
		
		
		
        .cmd { color: var(--cmd-main); font-weight: bold; }
        .arg { color: var(--cmd-args); }
        .hl { color: var(--hl-red); font-weight: bold; }

        .ans { 
            display: none; margin-top: 15px; padding: 15px; font-size: 0.9rem;
            background: rgba(35, 134, 54, 0.05); border-left: 4px solid var(--green-ans); border-radius: 4px;
        }

        .btn { 
            background: none; border: 1px solid var(--level-orange); color: var(--level-orange); 
            border-radius: 20px; cursor: pointer; font-size: 0.85rem; margin-top: 10px; padding: 6px 18px; font-weight: bold;
        }
        .btn:hover { background: var(--level-orange); color: #fff; }

        .footer { text-align: center; font-size: 0.8rem; padding: 30px; border-top: 1px solid var(--border); margin-top: 40px; }
    
	
	
	
	
.separator-blue {
    display: flex;
    align-items: center;
    text-align: center;
    margin: 40px 0; /* Espace au dessus et en dessous */
}

.separator-blue::before,
.separator-blue::after {
    content: '';
    flex: 1;
    border-bottom: 3px solid #007bff; /* √âpaisseur et couleur de la ligne bleue */
}

.separator-blue span {
    padding: 0 20px;
    font-weight: bold;
    color: #007bff;
    font-family: sans-serif;
    font-size: 1.1em;
    text-transform: uppercase;
    letter-spacing: 1px;
}
 
	
	
	
	
	
	
	
	
	
	
	</style>
</head>
<body>

    <div class="sidebar">
        <h2>üìÇ NAVIGATION</h2>
        <a href="index.html" class="menu-item">üè† Retour Accueil</a>
        <a href="piege_dbt.html" class="menu-item">üìô Voir la Pige dbt</a>

 
		
		
		<details class="menu-dropdown" open>
            <summary class="menu-item" style="cursor: pointer;">‚úÖ Questions d'Entra√Ænement</summary>
            <div class="sub-menu">
                <a href="dbt_qcm_001.html" class="menu-item sub-item active-page">üìù QCM 1 : Fondamentaux</a>
                <a href="dbt_qcm_002.html" class="menu-item sub-item">üöÄ EXAMEN BLANC FR</a>
				<a href="dbt_qcm_004.html" class="menu-item sub-item">üöÄ EXAMEN BLANC EN</a>
                <a href="dbt_qcm_003.html" class="menu-item sub-item">üéì QCM LEARN.GETDB</a>
                <a href="dbt_qcm_005.html" class="menu-item sub-item">‚ö†Ô∏è PI√àGES √Ä √âVITER</a>
				
                <a href="dbt_qcm_006.html" class="menu-item sub-item">üîß QCM 6 : Autres</a>
            </div>
        </details>
		
		
		
		
		
		
		
		
		
		
		
		
		
		
    </div>

    <div class="container">
	
	
	
	
	
	
	
	
	
	
	
	
	
	
        <h1>üß† dbt QCM : Session 1-65 üî•</h1>
        <div class="intro">Progression : 1 / 65. Focus sur la configuration des snapshots et le cycle de vie des objets.</div>






<div class="q-card">
            <span class="q-head_green">QUESTION 1/65 :: SOURCE CONFIGURATION</span>
            <span class="q-txt">You are setting up a Source for a table named <b>raw_transactions</b> in your dbt project. Your database is <b>raw_db</b> and schema is <b>public</b>. Which of the following is the most appropriate sources.yml configuration?</span>
            
            <div class="code-block">
                <b>A:</b><br>
                sources:<br>
                &nbsp;&nbsp;- name: raw_db<br>
                &nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: raw_transactions<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;database: raw_db<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema: public
            </div>

            <div class="code-block">
                <b>B:</b><br>
                sources:<br>
                &nbsp;&nbsp;- name: raw_db<br>
                &nbsp;&nbsp;&nbsp;&nbsp;schema: public<br>
                &nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: raw_transactions
            </div>

            <div class="code-block">
                <b>C :</b><br>
                sources:<br>
                &nbsp;&nbsp;- name: raw<br>
                &nbsp;&nbsp;&nbsp;&nbsp;database: raw_db<br>
                &nbsp;&nbsp;&nbsp;&nbsp;schema: public<br>
                &nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: raw_transactions
            </div>

            <div class="code-block">
                <b>D:</b><br>
                sources:<br>
                &nbsp;&nbsp;- name: raw_db<br>
                &nbsp;&nbsp;&nbsp;&nbsp;database: raw_db<br>
                &nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: raw_transactions<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema: public
            </div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ R√©ponse correcte : C</strong>
                <p>Le champ <b>name</b> du source est un alias logique (ici <b>raw</b>), alors que <b>database</b> et <b>schema</b> d√©crivent l‚Äôemplacement r√©el (<b>raw_db.public</b>).</p>
                <p>La table <b>raw_transactions</b> est correctement d√©finie dans tables, et la configuration correspond exactement au besoin : database = raw_db, schema = public.</p>
                
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 2/65 :: CONFIGURATION METHODS</span>
            <span class="q-txt">Which is a valid way to configure a model in dbt?</span>
            <div class="opt">A - Configuring inside a model's .sql file using a config block.</div>
            <div class="opt">B - Using dbt_project.yml to specify a folder-level config.</div>
            <div class="opt">C - Placing the config in a schema.yml file under the models: section.</div>
            <div class="opt">D - All of the above.</div>
            
            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ R√©ponse correcte : D - All of the above</strong>
                <p>Dans dbt, il existe trois m√©thodes valides pour configurer un mod√®le :</p>
                <ul>
                    <li><b>Dans le fichier .sql :</b> Utiliser un bloc config Jinja au d√©but du mod√®le : <code>{{ config(materialized='table') }}</code></li>
                    <li><b>Dans dbt_project.yml :</b> D√©finir des configurations au niveau du dossier ou projet.</li>
                    <li><b>Dans schema.yml :</b> Sp√©cifier les configurations sous la section models.</li>
                </ul>
                <p>Ordre de priorit√© : config dans le fichier .sql > schema.yml > dbt_project.yml.</p>
                
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_orange">QUESTION 3/65 :: INCREMENTAL REBUILD</span>
            <span class="q-txt">True or False: An incremental model in dbt will only rebuild rows that have changed based on the logic in the is_incremental() block, unless you run dbt run --full-refresh.</span>
            <div class="opt">A - True</div>
            <div class="opt">B - False</div>
            
            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ R√©ponse correcte : A - True</strong>
                <p>Cette affirmation est correcte. Voici comment fonctionnent les mod√®les incr√©mentaux :</p>
                <ul>
                    <li><b>Par d√©faut (run normal) :</b> dbt ne traite que les nouvelles donn√©es d√©finies dans le bloc <code>{% if is_incremental() %}</code>.</li>
                    <li><b>Avec --full-refresh :</b> dbt ignore la logique incr√©mentale et reconstruit compl√®tement la table depuis z√©ro.</li>
                </ul>
                <div class="code-block">
                    Exemple :<br>
                    {% if is_incremental() %}<br>
                    &nbsp;&nbsp;where event_date > (select max(event_date) from {{ this }})<br>
                    {% endif %}
                </div>
                
            </div>
        </div>
		
		
		
		
		<div class="q-card">
            <span class="q-head_green">QUESTION 4/65 :: EPHEMERAL MODELS</span>
            <span class="q-txt">You have two ephemeral models that feed a single final model which is materialized as a table. When you run <b>dbt run</b>, which statement is correct about ephemeral models?</span>
            
            <div class="opt">A - Ephemeral models generate physical tables in your data warehouse, which are later dropped.</div>
            <div class="opt">B - Ephemeral models compile as CTEs within the final model's SQL.</div>
            <div class="opt">C - Ephemeral models are treated as incremental models unless otherwise specified.</div>
            <div class="opt">D - Ephemeral models must be manually materialized as views.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B - Ephemeral models compile as CTEs within the final model's SQL.</strong>
                <p><b>Explication :</b> Les mod√®les √©ph√©m√®res (ephemeral) dans dbt ont un comportement tr√®s sp√©cifique :</p>
                <ul>
                    <li><b>Pas de tables physiques :</b> Contrairement aux autres mat√©rialisations (table, view, incremental), les mod√®les √©ph√©m√®res ne cr√©ent aucun objet physique dans le data warehouse. Donc A est faux.</li>
                    <li><b>Compilation en CTEs :</b> Quand tu ex√©cutes dbt run, dbt prend le code SQL des mod√®les √©ph√©m√®res et les int√®gre directement comme Common Table Expressions (CTEs) dans le SQL du mod√®le final qui les r√©f√©rence.</li>
                </ul>
                <div class="code-block">
                    <b>Exemple compil√© :</b><br>
                    WITH ephemeral_model_1 AS (<br>
                    &nbsp;&nbsp;select * from raw.users<br>
                    ),<br>
                    ephemeral_model_2 AS (<br>
                    &nbsp;&nbsp;select * from raw.orders<br>
                    )<br>
                    select * from ephemeral_model_1<br>
                    join ephemeral_model_2 ...
                </div>
                <p><b>Quand les utiliser :</b> Utiles pour la r√©utilisation de logique sans cr√©er d'objets interm√©diaires, mais attention aux performances car tout est ex√©cut√© en une seule requ√™te ! Les options C et D sont fausses.</p>
                
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 5/65 :: JINJA VARIABLE SYNTAX</span>
            <span class="q-txt">You want to dynamically select only rows created after a specific date in your model. Assume <b>target_date</b> is a variable you plan to pass. Which Jinja snippet in your .sql is most appropriate?</span>
            
            <div class="code-block">
                <b>A:</b><br>
                SELECT * FROM {{ ref('my_table') }} WHERE created_at > {{ target_date }}
            </div>

            <div class="code-block">
                <b>B :</b><br>
                SELECT * FROM {{ ref('my_table') }} WHERE created_at > <b>'{{ var('target_date') }}'</b>
            </div>

            <div class="code-block">
                <b>C:</b><br>
                SELECT * FROM {{ ref('my_table') }} WHERE created_at > "{{ ('target_date') }}"
            </div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B.</strong>
                <p><b>Explication :</b></p>
                <ul>
                    <li><b>Utilisation de var() :</b> Pour passer une variable √† un mod√®le dbt, tu dois utiliser la fonction Jinja <code>var('nom_de_variable')</code>.</li>
                    <li><b>Guillemets simples :</b> Comme target_date est une date (type string ou date), elle doit √™tre entour√©e de guillemets simples <code>'...'</code> dans le SQL final pour √™tre valide syntaxiquement.</li>
                </ul>
                <div class="code-block">
                    <b>Exemple d'appel :</b><br>
                    dbt run --vars '{"target_date": "2024-01-01"}'
                </div>
                <p>Pourquoi les autres sont fausses : A n'utilise pas var(), C a une syntaxe de guillemets/parenth√®ses incorrecte, et D utilise une seule accolade (non Jinja).</p>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 6/65 :: REFERENCING SEEDS</span>
            <span class="q-txt">You added a CSV file named <b>user_attributes.csv</b> into <b>seeds/</b>. You want to load it exactly as is and reference it in downstream models. Which code snippet is correct for referencing the seeded table?</span>
            
            <div class="opt">A - {{ ref('user_attributes') }}</div>
            <div class="opt">B - {{ source('seeds', 'user_attributes') }}</div>
            <div class="opt">C - {{ seed('user_attributes') }}</div>
            <div class="opt">D - {{ ref('seed_user_attributes') }}</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A - {{ ref('user_attributes') }}</strong>
                <p><b>Explication :</b></p>
                <ul>
                    <li><b>Les seeds dans dbt :</b> Quand tu ajoutes un CSV dans <code>seeds/</code>, tu utilises <code>dbt seed</code> pour le charger en tant que table.</li>
                    <li><b>R√©f√©rencer un seed :</b> Une fois charg√©, un seed se r√©f√©rence exactement comme un mod√®le dbt, avec la fonction <code>ref()</code>. Le nom utilis√© est le nom du fichier sans l'extension .csv.</li>
                </ul>
                <div class="code-block">
                    <b>Utilisation :</b><br>
                    select * from {{ ref('user_attributes') }}
                </div>
                <p><b>Diff√©rence cl√© :</b> <code>ref()</code> est pour les mod√®les et seeds. <code>source()</code> est pour les tables brutes externes. dbt ne pr√©fixe pas automatiquement avec seed_.</p>
            </div>
        </div>
		
		
		
		
		
		
		<div class="q-card">
            <span class="q-head_green">QUESTION 7/65 :: DATA TEST DEFINITION</span>
            <span class="q-txt">You want to ensure that the column <b>user_id</b> in the <b>fact_orders</b> model is always present (not null). How do you define this test in a <b>schema.yml</b> file?</span>
            
            <div class="code-block">
                <b>A:</b><br>
                models:<br>
                &nbsp;&nbsp;- name: fact_orders<br>
                &nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column: user_id
            </div>

            <div class="code-block">
                <b>B :</b><br>
                models:<br>
                &nbsp;&nbsp;- name: fact_orders<br>
                &nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: user_id<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null
            </div>

            <div class="code-block">
                <b>C:</b><br>
                models:<br>
                &nbsp;&nbsp;- name: fact_orders<br>
                &nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: user_id<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- test: not_null
            </div>

            <div class="code-block">
                <b>D:</b><br>
                tests:<br>
                &nbsp;&nbsp;not_null:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;fact_orders:<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_id
            </div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B.</strong>
                <p><b>Explication : Structure correcte des tests dans schema.yml</b></p>
                <p>Dans dbt, pour tester une colonne sp√©cifique, tu dois :</p>
                <ul>
                    <li>D√©finir le mod√®le sous <code>models:</code></li>
                    <li>D√©finir les colonnes sous <code>columns:</code></li>
                    <li>Sp√©cifier le nom de la colonne avec <code>- name: user_id</code></li>
                    <li>Ajouter les tests sous cette colonne avec <code>tests:</code></li>
                </ul>
                <p><b>Syntaxe du test :</b> Pour les tests g√©n√©riques simples comme not_null, unique, accepted_values, tu utilises simplement le nom du test directement : <code>- not_null</code></p>
                <p><b>Pourquoi les autres sont fausses :</b></p>
                <ul>
                    <li>A : Les tests sont d√©finis au niveau du mod√®le, pas au niveau de la colonne. Cette syntaxe est incorrecte.</li>
                    <li>C : La syntaxe - test: not_null est incorrecte.</li>
                    <li>D : Cette structure n'est pas du tout conforme √† la syntaxe dbt YAML</li>
                </ul>
                <div class="code-block">
                    <b>Exemple complet :</b><br>
                    version: 2<br><br>
                    models:<br>
                    &nbsp;&nbsp;- name: fact_orders<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;description: "Table des commandes"<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: user_id<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- relationships:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to: ref('dim_users')<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field: user_id
                </div>
                <div class="code-block">
                    <b>Ex√©cution :</b><br>
                    dbt test&nbsp;&nbsp;# Teste tous les mod√®les<br>
                    dbt test --select fact_orders&nbsp;&nbsp;# Teste uniquement fact_orders
                </div>
                
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 8/65 :: SNAPSHOT CONFIGURATION</span>
            <span class="q-txt">When configuring a snapshot in dbt, which key attribute is typically used to identify records uniquely?</span>
            
            <div class="opt">A - unique_key</div>
            <div class="opt">B - primary_key</div>
            <div class="opt">C - id</div>
            <div class="opt">D - record_key</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A - unique_key.</strong>
                <p><b>Explication : Configuration des snapshots dbt</b></p>
                <p>Dans dbt, les snapshots sont utilis√©s pour capturer l'√©tat d'une table √† diff√©rents moments dans le temps (Slowly Changing Dimensions - Type 2).</p>
                <p><b>L'attribut unique_key :</b> C'est le param√®tre officiel utilis√© pour identifier de mani√®re unique chaque enregistrement. Il indique √† dbt quelle colonne utiliser pour d√©tecter si un enregistrement est nouveau ou mis √† jour.</p>
                <div class="code-block">
                    <b>Exemple de configuration snapshot :</b><br>
                    {% snapshot orders_snapshot %}<br><br>
                    {{<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;config(<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target_schema='snapshots',<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unique_key='order_id',<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strategy='timestamp',<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updated_at='updated_at'<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;)<br>
                    }}<br><br>
                    select * from {{ source('raw', 'orders') }}<br><br>
                    {% endsnapshot %}
                </div>
                <p><b>Pourquoi les autres sont fausses :</b> B (primary_key), C (id) et D (record_key) ne sont pas les attributs de configuration valides dans dbt.</p>
                <p><b>Strat√©gies de snapshot :</b><br>
                - <b>timestamp :</b> Utilise une colonne updated_at.<br>
                - <b>check :</b> Compare certaines colonnes pour d√©tecter les changements.</p>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 9/65 :: DBT COMMANDS</span>
            <span class="q-txt">You want to run only the tests, without building any models. Which command accomplishes this?</span>
            
            <div class="opt">A - dbt test</div>
            <div class="opt">B - dbt run --test-only</div>
            <div class="opt">C - dbt run --exclude tests</div>
            <div class="opt">D - dbt compile --tests</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A - dbt test.</strong>
                <p><b>Explication : La commande dbt test</b></p>
                <p>C'est la commande officielle pour ex√©cuter uniquement les tests sans construire les mod√®les.</p>
                <ul>
                    <li>Ex√©cute les tests g√©n√©riques (not_null, unique, etc.) et singuliers.</li>
                    <li>Ne mat√©rialise aucun mod√®le.</li>
                    <li>Suppose que les mod√®les existent d√©j√† dans le data warehouse.</li>
                </ul>
                <div class="code-block">
                    <b>Variantes utiles :</b><br>
                    dbt test --select my_model # Un mod√®le sp√©cifique<br>
                    dbt test --select test_type:generic # Tests g√©n√©riques seulement<br>
                    dbt test --select state:modified # Mod√®les modifi√©s
                </div>
                <p><b>Workflow typique :</b> 1. <code>dbt run</code> (Construction) -> 2. <code>dbt test</code> (V√©rification).</p>
                
            </div>
        </div>
		
		
		
		
         <div class="q-card">
            <span class="q-head_green">QUESTION 10/65 :: DBT EXPOSURES</span>
            <span class="q-txt">Which statement best describes a dbt exposure?</span>
            
            <div class="opt">A - It is used to apply row-level security for specific tables.</div>
            <div class="opt">B - It documents how certain data sets (models) are used downstream, such as in dashboards or by certain teams.</div>
            <div class="opt">C - It is a feature that tracks all ephemeral models for debugging.</div>
            <div class="opt">D - It duplicates a set of transformations for auditing purposes.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B.</strong>
                <p><b>Explication : Les exposures dans dbt</b></p>
                <p>Les exposures sont des objets de documentation qui permettent de d√©finir comment tes mod√®les dbt sont utilis√©s en aval (downstream).</p>
                <ul>
                    <li><b>Objectifs :</b> Documenter les dashboards/rapports, cr√©er une tra√ßabilit√© (lineage), et comprendre l'impact des modifications sur les consommateurs finaux.</li>
                    <li><b>Lineage :</b> Elles apparaissent dans le DAG (Directed Acyclic Graph), montrant la connexion entre mod√®les et utilisations finales.</li>
                </ul>
                <div class="code-block">
                    <b>Exemple (exposures.yml) :</b><br>
                    exposures:<br>
                    &nbsp;&nbsp;- name: weekly_sales_dashboard<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;type: dashboard<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;depends_on:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- ref('fct_orders')
                </div>
                
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 11/65 :: NAMING CONVENTIONS</span>
            <span class="q-txt">True or False: dbt enforces a strict naming convention for your models, requiring them to be prefixed with stg_, fct_, or dim_.</span>
            
            <div class="opt">A - TRUE</div>
            <div class="opt">B - FALSE</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B - FALSE.</strong>
                <p><b>Explication :</b> dbt n'impose <b>PAS</b> de convention de nommage stricte. Il est flexible et ne force aucun pr√©fixe.</p>
                <ul>
                    <li><b>Conventions recommand√©es :</b> Bien que non impos√©, il est fortement conseill√© d'utiliser <code>stg_</code> (staging), <code>int_</code> (intermediate), <code>fct_</code> (fact) et <code>dim_</code> (dimension).</li>
                    <li><b>B√©n√©fice :</b> Cela facilite la clart√©, l'organisation par dossiers et l'utilisation de s√©lecteurs (ex: <code>dbt run --select stg_*</code>).</li>
                </ul>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 12/65 :: RUN_QUERY MACRO</span>
            <span class="q-txt">What does <b>run_query</b> macro typically do in a dbt project?</span>
            
            <div class="opt">A - It compiles and runs a SQL statement within the data warehouse at runtime, returning the results to your Jinja context.</div>
            <div class="opt">B - It triggers the entire dbt run pipeline from within your code.</div>
            <div class="opt">C - It is only used for snapshot logic in ephemeral models.</div>
            <div class="opt">D - It compiles the entire project but does not run any queries.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A.</strong>
                <p><b>Explication :</b> La macro <code>run_query</code> permet d'ex√©cuter une requ√™te SQL arbitraire pendant la compilation Jinja et de r√©cup√©rer les r√©sultats.</p>
                <ul>
                    <li><b>Usage :</b> R√©cup√©rer des m√©tadonn√©es ou des valeurs dynamiques (ex: trouver une date max) pour influencer la g√©n√©ration du SQL.</li>
                    <li><b>Retour :</b> Elle retourne un objet <i>agate.Table</i> manipulable en Jinja.</li>
                    <li><b>Note :</b> N√©cessite souvent le check <code>{% if execute %}</code>.</li>
                </ul>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 13/65 :: MACRO LOCATION</span>
            <span class="q-txt">You've written a custom macro in a file named <b>my_custom_macros.sql</b>. Which folder location in a typical dbt project is recommended?</span>
            
            <div class="opt">A - macros/</div>
            <div class="opt">B - models/</div>
            <div class="opt">C - tests/</div>
            <div class="opt">D - analysis/</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A - macros/.</strong>
                <p><b>Explication : Le dossier macros/</b></p>
                <p>C'est le dossier standard o√π dbt scanne automatiquement les macros pour les rendre disponibles dans tout le projet.</p>
                <div class="code-block">
                    <b>Structure type :</b><br>
                    my_dbt_project/<br>
                    ‚îú‚îÄ‚îÄ models/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# SQL des mod√®les<br>
                    ‚îú‚îÄ‚îÄ macros/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Macros personnalis√©es ‚Üê ICI<br>
                    ‚îú‚îÄ‚îÄ tests/ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Tests singuliers<br>
                    ‚îú‚îÄ‚îÄ dbt_project.yml
                </div>
            </div>
        </div>


<div class="q-card">
            <span class="q-head_green">QUESTION 14/65 :: REFERENCING VARIABLES</span>
            <span class="q-txt">You define a variable in <b>dbt_project.yml</b> like:</span>
            <div class="code-block">
                vars:<br>
                &nbsp;&nbsp;my_threshold: 100
            </div>
            <span class="q-txt">How do you reference this variable in a Jinja block within a model?</span>
            
            <div class="opt">A - SELECT * FROM table WHERE value > '{{ var("my_threshold") }}'</div>
            <div class="opt">B - SELECT * FROM table WHERE value > {{ var("my_threshold") }}</div>
            <div class="opt">C - SELECT * FROM table WHERE value > var("my_threshold")</div>
            <div class="opt">D - SELECT * FROM table WHERE value > config("my_threshold")</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B - SELECT * FROM table WHERE value > {{ var("my_threshold") }}</strong>
                <p><b>Explication : Syntaxe correcte pour r√©f√©rencer une variable</b></p>
                <p>Dans dbt, tu utilises la fonction Jinja <code>var()</code> entour√©e de doubles accolades <code>{{ }}</code> pour acc√©der aux variables d√©finies.</p>
                <ul>
                    <li><b>Pourquoi B est correct :</b> La valeur 100 est r√©cup√©r√©e sans guillemets car c'est un nombre. Le SQL compil√© sera : <code>WHERE value > 100</code>.</li>
                    <li><b>Pourquoi les autres sont fausses :</b>
                        <ul>
                            <li>A : Les guillemets simples transformeraient 100 en cha√Æne de caract√®res ('100').</li>
                            <li>C : Sans les accolades, la fonction n'est pas √©valu√©e par Jinja.</li>
                            <li>D : <code>config()</code> sert √† la configuration du mod√®le (mat√©rialisation, tags), pas aux variables.</li>
                        </ul>
                    </li>
                </ul>
                <p><b>Valeur par d√©faut :</b> Tu peux d√©finir une valeur de secours : <code>{{ var("my_threshold", 50) }}</code>.</p>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 15/65 :: REFERENTIAL INTEGRITY TESTS</span>
            <span class="q-txt">You have a <b>dim_users</b> and a <b>fact_orders</b> model. You want to ensure every <b>user_id</b> in <b>fact_orders</b> matches a record in <b>dim_users</b>. Which built-in test is best?</span>
            
            <div class="opt">A - not_null</div>
            <div class="opt">B - unique</div>
            <div class="opt">C - accepted_values</div>
            <div class="opt">D - relationships</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est D - relationships.</strong>
                <p><b>Explication : Le test relationships</b></p>
                <p>C'est le test dbt con√ßu sp√©cifiquement pour v√©rifier l'int√©grit√© r√©f√©rentielle (√©quivalent d'une foreign key).</p>
                <div class="code-block">
                    <b>Configuration (schema.yml) :</b><br>
                    - name: user_id<br>
                    &nbsp;&nbsp;tests:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;- relationships:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to: ref('dim_users')<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field: user_id
                </div>
                <p><b>Ce que fait le test :</b> Il g√©n√®re une requ√™te SQL pour trouver les <code>user_id</code> orphelins dans <code>fact_orders</code> qui n'existent pas dans <code>dim_users</code>.</p>
                
                <p><b>Pourquoi les autres sont fausses :</b> <i>not_null</i> v√©rifie l'absence de vide, <i>unique</i> v√©rifie l'absence de doublons, et <i>accepted_values</i> v√©rifie une liste fixe de valeurs.</p>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 16/65 :: DBT COMPILE COMMAND</span>
            <span class="q-txt">Which statement is true regarding the <b>dbt compile</b> command?</span>
            
            <div class="opt">A - It compiles and runs the SQL to produce tables/views.</div>
            <div class="opt">B - It only compiles your models into the target/ directory but does not run them.</div>
            <div class="opt">C - It compiles your macros but does not create a target/ directory.</div>
            <div class="opt">D - It is functionally identical to dbt run.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B.</strong>
                <p><b>Explication : La commande dbt compile</b></p>
                <p>Elle transforme le code Jinja (ref, source, variables) en SQL pur mais <b>n'ex√©cute rien</b> dans le data warehouse.</p>
                <ul>
                    <li><b>Dossier target/compiled/ :</b> Contient le SQL final pr√™t √† √™tre inspect√©.</li>
                    <li><b>Utilit√© :</b> Debugging, inspection du code g√©n√©r√©, v√©rification de la syntaxe en CI/CD sans toucher aux donn√©es.</li>
                </ul>
                <div class="code-block">
                    <b>Workflow :</b><br>
                    1. <code>dbt compile</code> (V√©rifier le SQL g√©n√©r√©)<br>
                    2. <code>dbt run</code> (Ex√©cuter r√©ellement)
                </div>
                
            </div>
        </div>
		
		
		
		
		<div class="q-card">
            <span class="q-head_green">QUESTION 17/65 :: SOURCE FRESHNESS</span>
            <span class="q-txt">True or False: You can test how up-to-date a source table is by defining a freshness check in <b>sources.yml</b>.</span>
            
            <div class="opt">A - True</div>
            <div class="opt">B - False</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A - True.</strong>
                <p><b>Explication : Les freshness checks</b></p>
                <p>C'est une fonctionnalit√© dbt qui permet de v√©rifier si une table source a √©t√© mise √† jour r√©cemment, utile pour d√©tecter les probl√®mes dans les pipelines en amont.</p>
                <div class="code-block">
                    <b>Configuration (sources.yml) :</b><br>
                    freshness:<br>
                    &nbsp;&nbsp;warn_after: {count: 12, period: hour}<br>
                    &nbsp;&nbsp;error_after: {count: 24, period: hour}<br>
                    tables:<br>
                    &nbsp;&nbsp;- name: orders<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;loaded_at_field: updated_at
                </div>
                <p><b>Commande :</b> <code>dbt source freshness</code></p>
                <p><b>Ce que fait le check :</b> dbt ex√©cute <code>SELECT MAX(loaded_at_field) FROM source_table</code> et compare le r√©sultat avec l'heure actuelle. Si la diff√©rence d√©passe les seuils fix√©s, dbt renvoie un warning ou une erreur.</p>
                
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 18/65 :: SNAPSHOT VS INCREMENTAL</span>
            <span class="q-txt">Which of the following is a primary reason to use a snapshot over an incremental model?</span>
            
            <div class="opt">A - Snapshots are faster to build than incremental models.</div>
            <div class="opt">B - napshots track row-level changes over time, whereas incremental models usually contain only the latest state.</div>
            <div class="opt">C - Snapshots do not require a unique key to identify rows.</div>
            <div class="opt">D - Snapshots do not allow usage of is_incremental() logic.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B - Snapshots track row-level changes over time, whereas incremental models usually contain only the latest state.</strong>
                <p><b>Explication : Diff√©rence fondamentale</b></p>
                <ul>
                    <li><b>Snapshots (SCD Type 2) :</b> Capturent l'historique complet. Chaque changement cr√©e une nouvelle ligne avec des colonnes de validit√© (<code>dbt_valid_from</code>, <code>dbt_valid_to</code>). Parfait pour l'audit et l'analyse "point-in-time".</li>
                    <li><b>Mod√®les incr√©mentaux :</b> Optimis√©s pour la performance, ils ne conservent g√©n√©ralement que l'√©tat actuel (les anciennes valeurs sont √©cras√©es ou non captur√©es).</li>
                </ul>
                <div class="code-block">
                    <b>Colonnes ajout√©es par dbt dans un snapshot :</b><br>
                    - dbt_valid_from / dbt_valid_to<br>
                    - dbt_updated_at<br>
                    - dbt_scd_id (ID unique de version)
                </div>
                
                <p><b>Pourquoi les autres sont fausses :</b> A est faux (les snapshots sont souvent plus lents), C est faux (le <code>unique_key</code> est obligatoire).</p>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 19/65 :: DBT CLEAN COMMAND</span>
            <span class="q-txt">What does <b>dbt clean</b> do?</span>
            
            <div class="opt">A - Removes all tables in the data warehouse created by dbt.</div>
            <div class="opt">B - Cleans and rebuilds your entire dbt environment, including installing packages.</div>
            <div class="opt">C - Removes the target/ and dbt_packages/ directories in your local filesystem.</div>
            <div class="opt">D - Deletes ephemeral models from the data warehouse.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est C - Removes the target/ and dbt_packages/ directories in your local filesystem.</strong>
                <p><b>Explication : La commande dbt clean</b></p>
                <p>C'est une commande de maintenance <b>locale</b>. Elle ne touche <b>PAS</b> au data warehouse.</p>
                <ul>
                    <li><b>Supprime :</b> Le dossier <code>target/</code> (fichiers compil√©s, logs, manifest) et le dossier <code>dbt_packages/</code> (d√©pendances install√©es).</li>
                    <li><b>Utilit√© :</b> R√©soudre des probl√®mes de compilation, nettoyer avant un upgrade, ou lib√©rer de l'espace disque.</li>
                </ul>
                <div class="code-block">
                    <b>Workflow typique :</b><br>
                    dbt clean<br>
                    dbt deps<br>
                    dbt compile
                </div>
                <p><b>Attention :</b> Apr√®s un clean, vous devez relancer <code>dbt deps</code> pour r√©installer vos packages.</p>
            </div>
        </div>
		
		
		
		<div class="q-card">
            <span class="q-head_green">QUESTION 20/65 :: DBT PACKAGES</span>
            <span class="q-txt">True or False: dbt supports installing community or custom packages (projects) via a <b>packages.yml</b> file, which can then be referenced like macros in your local project.</span>
            
            <div class="opt">A - true</div>
            <div class="opt">B - false</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A - true.</strong>
                <p><b>Explication : Les packages dbt</b></p>
                <p>dbt supporte un syst√®me de packages similaire √† npm ou pip, permettant d'installer des projets r√©utilisables.</p>
                <ul>
                    <li><b>Fichier packages.yml :</b> Sert √† d√©clarer les packages (ex: <code>dbt-labs/dbt_utils</code>).</li>
                    <li><b>Commande :</b> <code>dbt deps</code> t√©l√©charge les fichiers dans <code>dbt_packages/</code>.</li>
                    <li><b>Utilisation :</b> Une fois install√©s, vous utilisez leurs macros comme si elles √©taient locales (ex: <code>{{ dbt_utils.generate_surrogate_key(...) }}</code>).</li>
                </ul>
                <div class="code-block">
                    <b>Sources possibles :</b><br>
                    - dbt Hub (officiel)<br>
                    - GitHub (via URL git)<br>
                    - Local (chemin relatif)
                </div>
                
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 21/65 :: VIEW VS TABLE PERFORMANCE</span>
            <span class="q-txt">True or False: A view materialization in dbt will always be more performant than a table materialization.</span>
            
            <div class="opt">A - true</div>
            <div class="opt">B - false</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B - false.</strong>
                <p><b>Explication :</b> Une vue n'est PAS toujours plus performante qu'une table. C'est m√™me souvent l'inverse.</p>
                <ul>
                    <li><b>View :</b> Rapide √† construire (pas de stockage), mais <b>lente √† interroger</b> car la logique SQL est r√©ex√©cut√©e √† chaque fois.</li>
                    <li><b>Table :</b> Longue √† construire (stockage physique), mais <b>tr√®s rapide √† interroger</b> car les donn√©es sont d√©j√† pr√©-calcul√©es.</li>
                </ul>
                <p><b>Best practice :</b> Utilisez des tables pour les transformations complexes (joins, agr√©gations) sollicit√©es par des outils de BI ou des mod√®les en aval.</p>
                [Image comparing dbt view vs table materialization processing flow]
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 22/65 :: SEED COLUMN TYPES</span>
            <span class="q-txt">When loading a seed, how can you control the column data types in the warehouse?</span>
            
            <div class="opt">A - Modify the CSV file's header row with typed columns.</div>
            <div class="opt">B - Adjust types in the seeds: config within dbt_project.yml.</div>
            <div class="opt">C - Use a pre-hook macro to cast each column.</div>
            <div class="opt">D - You cannot control data types of seeds.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B - Adjust types in the seeds: config within dbt_project.yml.</strong>
                <p><b>Explication :</b> dbt permet de sp√©cifier explicitement les types de donn√©es via la configuration <code>column_types</code>.</p>
                <div class="code-block">
                    <b>Exemple (dbt_project.yml) :</b><br>
                    seeds:<br>
                    &nbsp;&nbsp;my_project:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;country_codes:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+column_types:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;country_code: varchar(2)<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;population: bigint
                </div>
                <p><b>Pourquoi c'est important :</b> Cela garantit l'int√©grit√© des donn√©es, optimise le stockage et √©vite les erreurs de conversion (casting) lors des jointures ult√©rieures.</p>
            </div>
        </div>

    
	
	
	
	<div class="q-card">
    <span class="q-head_green">QUESTION 23/65 :: BIGQUERY PARTITIONING</span>
    <span class="q-txt">You want to create a partitioned table on BigQuery, partitioned by <code>created_at</code>. Which snippet is valid in your .sql config block?</span>
    
    <div class="opt">A
<pre>{{ config(
    materialized='table',
    partition_by='created_at',
    cluster_by=['user_id']
) }}</pre></div>
    
    <div class="opt">B
<pre>{{ config(
    materialized='table',
    partition_by={"field": "created_at", "data_type": "date"},
    cluster_by=["user_id"]
) }}</pre></div>
    
    <div class="opt">C
<pre>{{ config(
    materialized='table',
    partition_on='created_at'
) }}</pre></div>
    
    <div class="opt">D
<pre>{{ config(
    materialized='incremental',
    partition_by='created_at'
) }}</pre></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Partitionnement sur BigQuery dans dbt : Pour cr√©er une table partitionn√©e sur BigQuery, tu dois utiliser un dictionnaire pour sp√©cifier le champ et le type de donn√©es dans <code>partition_by</code>.</p>

        <h3>Syntaxe correcte pour BigQuery :</h3>
        <div class="code-block">
<b># Structure de base :</b><br>
partition_by={<br>
&nbsp;&nbsp;"field": "nom_colonne",<br>
&nbsp;&nbsp;"data_type": "date|timestamp|datetime",<br>
&nbsp;&nbsp;"granularity": "day|hour|month|year"  <span class="comment"># optionnel</span><br>
}
        </div>

        <h3>Exemple complet :</h3>
        <div class="code-block">
{{ config(<br>
&nbsp;&nbsp;materialized='table',<br>
&nbsp;&nbsp;partition_by={<br>
&nbsp;&nbsp;&nbsp;&nbsp;"field": "created_at",<br>
&nbsp;&nbsp;&nbsp;&nbsp;"data_type": "date",<br>
&nbsp;&nbsp;&nbsp;&nbsp;"granularity": "day"<br>
&nbsp;&nbsp;},<br>
&nbsp;&nbsp;cluster_by=["user_id", "status"]<br>
) }}<br>
<br>
<span class="keyword">select</span><br>
&nbsp;&nbsp;user_id,<br>
&nbsp;&nbsp;order_id,<br>
&nbsp;&nbsp;status,<br>
&nbsp;&nbsp;created_at<br>
<span class="keyword">from</span> {{ source('raw', 'orders') }}
        </div>

        <h3>Pourquoi les autres sont fausses :</h3>
        <ul>
            <li><b>A ‚ùå :</b> <code>partition_by='created_at'</code> est une syntaxe simplifi√©e qui peut fonctionner sur certains warehouses (comme Snowflake), mais sur BigQuery, il faut sp√©cifier le format dictionnaire avec <code>field</code> et <code>data_type</code>.</li>
            <li><b>C ‚ùå :</b> <code>partition_on</code> n'est pas le bon param√®tre. C'est <code>partition_by</code>.</li>
            <li><b>D ‚ùå :</b> Bien que la syntaxe soit proche, la question demande sp√©cifiquement une table partitionn√©e, pas un mod√®le incr√©mental. De plus, m√™me pour un mod√®le incr√©mental sur BigQuery, tu devrais utiliser le format dictionnaire complet.</li>
        </ul>

        <h3>Types de partitionnement sur BigQuery :</h3>
        <div class="code-block">
<b># Date/Timestamp (le plus courant) :</b><br>
partition_by={"field": "order_date", "data_type": "date"}<br>
<br>
<b># Ingestion time (par _PARTITIONTIME) :</b><br>
partition_by={<br>
&nbsp;&nbsp;"field": "_PARTITIONTIME",<br>
&nbsp;&nbsp;"data_type": "timestamp",<br>
&nbsp;&nbsp;"granularity": "day"<br>
}<br>
<br>
<b># Integer range (pour plages d'entiers) :</b><br>
partition_by={<br>
&nbsp;&nbsp;"field": "customer_id",<br>
&nbsp;&nbsp;"data_type": "int64",<br>
&nbsp;&nbsp;"range": {"start": 0, "end": 100000, "interval": 1000}<br>
}
        </div>

        <h3>Clustering en compl√©ment :</h3>
        <p>Le <code>cluster_by</code> organise les donn√©es √† l'int√©rieur de chaque partition pour am√©liorer encore les performances :</p>
        
        <div class="code-block">
<b># Clustering sur une colonne :</b><br>
cluster_by=["user_id"]<br>
<br>
<b># Clustering sur plusieurs colonnes :</b><br>
cluster_by=["user_id", "product_category", "region"]
        </div>

        <h3>B√©n√©fices du partitionnement BigQuery :</h3>
        <ul>
            <li><b>Performance :</b> Les requ√™tes qui filtrent sur la colonne de partition sont beaucoup plus rapides</li>
            <li><b>Co√ªt :</b> BigQuery scanne moins de donn√©es ‚Üí co√ªts r√©duits</li>
            <li><b>Maintenance :</b> Facilite la suppression/gestion de donn√©es anciennes</li>
        </ul>

        <h3>Exemple de requ√™te optimis√©e :</h3>
        <div class="code-block">
<b># Scanne uniquement la partition du 2024-01-15 :</b><br>
<span class="keyword">SELECT</span> *<br>
<span class="keyword">FROM</span> analytics.fct_orders<br>
<span class="keyword">WHERE</span> created_at = <span class="string">'2024-01-15'</span><br>
<span class="comment">-- ‚Üí Ne scanne que les donn√©es de cette partition</span>
        </div>

        <h3>Syntaxe sp√©cifique √† chaque data warehouse :</h3>
        <div class="code-block">
<b># BigQuery (dictionnaire) :</b><br>
partition_by={"field": "date", "data_type": "date"}<br>
<br>
<b># Snowflake (simple) :</b><br>
partition_by="date"<br>
<br>
<b># Redshift (autre syntaxe) :</b><br>
dist='key'<br>
sort=['date']<br>
<br>
<b># Databricks (Delta Lake) :</b><br>
partition_by="date"
        </div>

        <h3>V√©rification de la configuration :</h3>
        <div class="code-block">
<b># Compiler pour voir le SQL g√©n√©r√© :</b><br>
<span class="keyword">dbt compile</span> --select your_model<br>
<br>
<b># Voir le SQL dans target/compiled :</b><br>
<span class="comment">-- BigQuery g√©n√®re :</span><br>
CREATE OR REPLACE TABLE `project.dataset.table`<br>
PARTITION BY DATE(created_at)<br>
CLUSTER BY user_id<br>
AS (<br>
&nbsp;&nbsp;SELECT ...<br>
)
        </div>

        <h3>Exemple r√©el avec partition et clustering :</h3>
        <div class="code-block">
{{ config(<br>
&nbsp;&nbsp;materialized='table',<br>
&nbsp;&nbsp;partition_by={<br>
&nbsp;&nbsp;&nbsp;&nbsp;"field": "event_date",<br>
&nbsp;&nbsp;&nbsp;&nbsp;"data_type": "date",<br>
&nbsp;&nbsp;&nbsp;&nbsp;"granularity": "day"<br>
&nbsp;&nbsp;},<br>
&nbsp;&nbsp;cluster_by=[<br>
&nbsp;&nbsp;&nbsp;&nbsp;"user_id",<br>
&nbsp;&nbsp;&nbsp;&nbsp;"event_type",<br>
&nbsp;&nbsp;&nbsp;&nbsp;"country"<br>
&nbsp;&nbsp;]<br>
) }}<br>
<br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;user_id,<br>
&nbsp;&nbsp;event_type,<br>
&nbsp;&nbsp;country,<br>
&nbsp;&nbsp;DATE(created_at) <span class="keyword">AS</span> event_date,<br>
&nbsp;&nbsp;COUNT(*) <span class="keyword">AS</span> event_count<br>
<span class="keyword">FROM</span> {{ source('analytics', 'events') }}<br>
<span class="keyword">GROUP BY</span> 1, 2, 3, 4
        </div>

        <p>Cette question teste ta connaissance des configurations sp√©cifiques √† BigQuery dans dbt, important pour l'optimisation des performances et la r√©duction des co√ªts !</p>
    </div>
</div>
	
	
	
	
	
	
	
	
		
		
		
		<div class="q-card">
            <span class="q-head_orange">QUESTION 24/65 :: SNAPSHOT CONFIGURATION IN DBT_PROJECT.YML</span>
            <span class="q-txt">True or False: You can configure snapshot-specific settings (e.g., unique keys, database, schema) in <b>dbt_project.yml</b> under a <b>snapshots:</b> key.</span>
            
            <div class="opt">A - <b>true</div>
            <div class="opt">B - false</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A - true.</strong>
                <p><b>Explication : Configuration des snapshots</b></p>
                <p>Tu peux d√©finir des configurations pour tes snapshots au niveau du projet ou par dossier dans le fichier <code>dbt_project.yml</code> sous la cl√© <code>snapshots:</code>.</p>
                <div class="code-block">
                    <b>Exemple (dbt_project.yml) :</b><br>
                    snapshots:<br>
                    &nbsp;&nbsp;my_project:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;+target_schema: snapshots<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;+target_database: analytics<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;orders_snapshot:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+unique_key: order_id<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+strategy: timestamp
                </div>
                <p><b>Hi√©rarchie :</b> La configuration dans le fichier <code>.sql</code> du snapshot reste prioritaire, suivie par celle du <code>dbt_project.yml</code> (du plus sp√©cifique au plus global).</p>
                <p><b>Avantages :</b> Centralisation des param√®tres, gestion simplifi√©e du multi-environnement (ex: sch√©mas diff√©rents pour dev/prod) et respect du principe DRY.</p>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 25/65 :: CHANGING MATERIALIZATION (TABLE TO VIEW)</span>
            <span class="q-txt">If you change the materialization of a model from <b>table</b> to <b>view</b>, then run <b>dbt run</b>, what typically happens?</span>
            
            <div class="opt">A - dbt automatically drops the existing table and recreates a view.</div>
            <div class="opt">B - An error is thrown because you cannot overwrite a table with a view.</div>
            <div class="opt">C - dbt renames the table and creates a view with the original name.</div>
            <div class="opt">D - dbt appends data to the existing table, ignoring the materialization change.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B - An error is thrown because you cannot overwrite a table with a view.</strong>
                <p><b>Explication Correcte :</b></p>
                <p>dbt <b>NE remplace PAS</b> automatiquement une table par une view. En raison de la diff√©rence fondamentale entre ces objets, dbt va g√©n√©rer une erreur car il tentera de cr√©er une vue l√† o√π une table de m√™me nom existe d√©j√†.</p>
                <ul>
                    <li><b>Solution manuelle :</b> Tu dois supprimer la table manuellement dans le warehouse (<code>DROP TABLE schema.my_model;</code>) avant de relancer <code>dbt run</code>.</li>
                    <li><b>Alternative :</b> Utiliser <code>--full-refresh</code> peut parfois aider selon l'adaptateur du warehouse.</li>
                </ul>
                <p><b>Point crucial pour la certification :</b> Le passage de <b>table √† view</b> n√©cessite souvent une intervention manuelle contrairement √† d'autres changements de mat√©rialisation.</p>
            </div>
        </div>

       <div class="q-card">
            <span class="q-head_green">QUESTION 26/65 :: INCREMENTAL SCHEMA CHANGES</span>
            <span class="q-txt">You have an incremental model. You want the target table to <b>automatically sync</b> any new columns that appear in the schema. Which config is correct?</span>
            
            <div class="opt">A - on_schema_change='append_new_columns'</div>
            <div class="opt">B - on_schema_change='fail'</div>
            <div class="opt">C - on_schema_change='ignore'</div>
            <div class="opt">D - on_schema_change='sync_all_columns'</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ R√©ponse correcte : D</strong>
                <hr>
                <p><b>Explication :</b> Le param√®tre <code>on_schema_change</code> contr√¥le comment dbt r√©agit lorsque le sch√©ma de la source √©volue par rapport √† la table cible existante.</p>

                

                <h4>üõ†Ô∏è Analyse des options :</h4>
                <ul>
                    <li><b>sync_all_columns (D) :</b> C'est l'option la plus compl√®te. Elle ajoute les nouvelles colonnes ET supprime celles qui ne sont plus pr√©sentes dans le SQL du mod√®le. Elle garantit une synchronisation parfaite.</li>
                    <li><b>append_new_columns (A) :</b> Ajoute uniquement les nouvelles colonnes mais ne nettoie pas les anciennes.</li>
                    <li><b>fail (B) :</b> Bloque le run dbt en cas de diff√©rence, for√ßant une intervention manuelle (utile pour les environnements critiques).</li>
                    <li><b>ignore (C) :</b> Comportement par d√©faut. dbt continue l'insertion mais les nouvelles colonnes sont perdues car elles n'existent pas dans la table cible.</li>
                </ul>

                <h4>üìã Tableau comparatif des comportements :</h4>
                <table style="width:100%; border-collapse: collapse; margin-top:10px;">
                    <tr style="background-color: #f2f2f2;">
                        <th style="border: 1px solid #ddd; padding: 8px;">Option</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">Nouvelles colonnes</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">Colonnes supprim√©es</th>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>sync_all_columns</b></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">‚úÖ Ajout√©es</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">‚úÖ Supprim√©es</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;"><b>append_new_columns</b></td>
                        <td style="border: 1px solid #ddd; padding: 8px;">‚úÖ Ajout√©es</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">‚ùå Ignor√©es</td>
                    </tr>
                </table>

                <p><i>Note : Ce param√®tre est sp√©cifique aux mod√®les <b>incremental</b>. Pour les tables standards, dbt utilise <code>CREATE OR REPLACE</code>, donc le sch√©ma est naturellement mis √† jour √† chaque ex√©cution.</i></p>
            </div>
        </div>
		
		
		
		
		
		<div class="q-card">
            <span class="q-head_green">QUESTION 27/65 :: PARTIAL PARSING</span>
            <span class="q-txt">True or False: Partial parsing in dbt allows dbt to skip re-parsing all project files if only a few files changed, improving performance.</span>
            
            <div class="opt">A - true</div>
            <div class="opt">B - false</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A - true.</strong>
                <p><b>Explication : Le partial parsing</b></p>
                <p>C'est une optimisation qui permet √† dbt de ne r√©-analyser que les fichiers modifi√©s en s'appuyant sur un cache (<code>partial_parse.pkl</code>).</p>
                <ul>
                    <li><b>Gain :</b> R√©duit le temps de d√©marrage des commandes de plusieurs secondes √† quelques millisecondes sur les gros projets.</li>
                    <li><b>Invalidation :</b> Le cache est r√©initialis√© en cas de changement dans <code>dbt_project.yml</code>, installation de nouveaux packages ou changement de version de dbt.</li>
                </ul>
                <p>Activ√© par d√©faut depuis la v1.0, il est essentiel pour le confort de d√©veloppement.</p>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 28/65 :: GRAPH CONTEXT VARIABLE</span>
            <span class="q-txt">In dbt, what does the <b>graph</b> context variable typically provide inside macros?</span>
            
            <div class="opt">A - It provides the entire DAG structure, including dependencies between models</div>
            <div class="opt">B - It is used to reference ephemeral models only.</div>
            <div class="opt">C - It stores environment variables for the project.</div>
            <div class="opt">D - It's not a recognized context variable in dbt.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est A.</strong>
                <p><b>Explication : La variable graph</b></p>
                <p>C'est l'une des variables Jinja les plus puissantes. Elle contient un dictionnaire repr√©sentant l'int√©gralit√© du projet (le DAG).</p>
                <ul>
                    <li><b>nodes :</b> Tous les mod√®les, seeds, snapshots et tests.</li>
                    <li><b>sources :</b> Toutes les sources d√©finies.</li>
                    <li><b>Utilisation :</b> Permet de cr√©er des macros dynamiques (ex: lister tous les mod√®les d'un sch√©ma sp√©cifique ou trouver les mod√®les sans parents).</li>
                </ul>
                <div class="code-block">
                    <b>Exemple :</b> {% for node in graph.nodes.values() %} ... {% endfor %}
                </div>
                
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 29/65 :: STATE COMPARISON</span>
            <span class="q-txt">You want to only run models that have changed since the last successful run. Which feature/flag is relevant?</span>
            
            <div class="opt">A - --full-refresh</div>
            <div class="opt">B - -state</div>
            <div class="opt">C - --models changed</div>
            <div class="opt">D - dbt deps</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B --state.</strong>
                <p><b>Explication : Le flag --state</b></p>
                <p>Utilis√© pour la comparaison d'√©tat (State Comparison), il permet d'isoler les modifications par rapport √† un √©tat de r√©f√©rence (g√©n√©ralement la production).</p>
                <ul>
                    <li><b>S√©lecteur utile :</b> <code>state:modified</code> identifie les mod√®les dont le code a chang√©.</li>
                    <li><b>N√©cessite :</b> Les fichiers <code>manifest.json</code> et <code>run_results.json</code> d'un run pr√©c√©dent.</li>
                </ul>
                <div class="code-block">
                    <b>Commande type en CI :</b><br>
                    dbt run --state path/to/artifacts --select state:modified+
                </div>
            </div>
        </div>







<div class="q-card">
    <span class="q-head_green">QUESTION 30/65 :: GENERIC TEST SYNTAX (YAML)</span>
    <span class="q-txt">Which snippet is a valid definition of a generic test for <b>accepted_values</b>?</span>
    
    <div class="opt">A.
<pre>tests:
  - accepted_values:
      column_name: subscription_status
      values: ['active', 'inactive']</pre></div>
    
    <div class="opt">B.
<pre>columns:
  - name: subscription_status
    tests:
      - accepted_values:
          values: ['active', 'inactive']</pre></div>
    
    <div class="opt">C.
<pre>models:
  - name: users
    columns:
      - name: subscription_status
        tests:
          - accepted_values:
              values: ['active', 'inactive']</pre></div>
    
    <div class="opt">D.
<pre>models:
  - name: users
    columns:
      - name: subscription_status
        test:
          accepted_values: ['active', 'inactive']</pre></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : C</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>La syntaxe correcte pour d√©finir un test g√©n√©rique <b>accepted_values</b> dans un fichier de propri√©t√©s (<code>schema.yml</code>) n√©cessite une hi√©rarchie compl√®te avec la structure <b>models ‚Üí columns ‚Üí tests</b>.</p>

        <h3>Pourquoi C est correct :</h3>
        <p>La structure compl√®te doit respecter cette hi√©rarchie :</p>
        <ul>
            <li><b>models:</b> - Niveau racine pour d√©clarer les mod√®les</li>
            <li>&nbsp;&nbsp;<b>- name: users</b> - Nom du mod√®le</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;<b>columns:</b> - Section des colonnes du mod√®le</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>- name: subscription_status</b> - Nom de la colonne √† tester</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>tests:</b> - Liste des tests √† appliquer (<b>pluriel !</b>)</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>- accepted_values:</b> - Type de test</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>values: [...]</b> - Param√®tre du test avec les valeurs accept√©es</li>
        </ul>

        <h3>Pourquoi les autres sont incorrects :</h3>
        <ul>
            <li><b>A. Tests sans contexte :</b> Manque la d√©claration du mod√®le et de la colonne. <code>column_name</code> n'est pas le param√®tre correct (c'est juste <code>values</code>). Structure incompl√®te.</li>
            <li><b>B. Colonnes sans mod√®le :</b> Manque la d√©claration <code>models:</code> au d√©but. Les colonnes doivent √™tre d√©finies dans le contexte d'un mod√®le sp√©cifique.</li>
            <li><b>D. Utilisation de test (singulier) :</b> C'est <code>tests:</code> (pluriel) pas <code>test:</code> (singulier). La syntaxe <code>accepted_values: [...]</code> directement est incorrecte ; elle doit √™tre pr√©c√©d√©e d'un tiret et suivie de <code>values:</code> en dessous.</li>
        </ul>

        <h3>Exemple complet dans schema.yml :</h3>
        <div class="code-block">
version: 2<br><br>
models:<br>
&nbsp;&nbsp;- name: users<br>
&nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: subscription_status<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description: "Current subscription status"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- accepted_values:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values: ['active', 'inactive', 'pending']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null
        </div>
        <p>La syntaxe correcte est essentielle pour que dbt reconnaisse et ex√©cute les tests lors de <code>dbt test</code>.</p>
    </div>
</div>






<div class="q-card">
    <span class="q-head_green">QUESTION 31/65 :: INCREMENTAL MODEL ISSUE</span>
    <span class="q-txt">You have a model named <code class="highlight">stg_events_incremental</code> which is materialized as <b>incremental</b>. In your .sql file, you have logic in the <code class="highlight">is_incremental()</code> block that only selects rows with a timestamp greater than the max timestamp already loaded in your warehouse table. However, after each run, you notice that all data is reloaded rather than just new data. Which of the following most likely explains why all rows are reloaded?</span>
    
    <div class="opt">A. You forgot to include <code>if is_incremental()</code> logic at the top, and the code is applying the timestamp filter incorrectly.</div>
    <div class="opt">B. The table is set as <code>materialized='table'</code> in <code>dbt_project.yml</code>, overriding your .sql file config.</div>
    <div class="opt">C. You used <code>if not is_incremental()</code> instead of <code>if is_incremental()</code>, causing the filter to be skipped during incremental builds.</div>
    <div class="opt">D. You are using <code class="highlight">dbt run --full-refresh</code>, which truncates and rebuilds the table each time.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : D</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Le flag <code class="highlight">--full-refresh</code> force <b>dbt</b> √† ignorer compl√®tement la logique incr√©mentale et √† reconstruire enti√®rement la table √† chaque ex√©cution.</p>

        <h3>Comment fonctionne --full-refresh :</h3>
        <p>Lorsque vous utilisez <code class="highlight">dbt run --full-refresh</code> :</p>
        <ul>
            <li>La fonction <code class="highlight">is_incremental()</code> retourne toujours <code>False</code></li>
            <li>Toute la logique dans le bloc <code>{% if is_incremental() %}</code> est ignor√©e</li>
            <li>La table est tronqu√©e (DROP + CREATE) ou recr√©√©e compl√®tement</li>
            <li>Toutes les donn√©es sont recharg√©es depuis la source</li>
        </ul>

        <h3>Exemple de mod√®le incr√©mental :</h3>
        <div class="code-block">
{{
  config(
    materialized='incremental',
    unique_key='event_id'
  )
}}

select * from {{ source('events', 'raw_events') }}

{% if is_incremental() %}
  -- Cette logique est IGNOR√âE avec --full-refresh
  where event_timestamp > (select max(event_timestamp) from {{ this }})
{% endif %}
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>A. Oubli du if is_incremental() :</b> Si le <code>if</code> √©tait oubli√©, la requ√™te √©chouerait ou produirait une erreur. Le comportement d√©crit est syst√©matique (√† chaque run), pas une erreur de logique.</li>
            <li><b>B. materialized='table' dans dbt_project.yml :</b> Les configs dans le fichier mod√®le (.sql) ont priorit√© sur <code class="highlight">dbt_project.yml</code>. De plus, m√™me avec <code>materialized='table'</code>, ce ne serait pas incr√©mental du tout.</li>
            <li><b>C. if not is_incremental() :</b> Cela signifierait que la logique s'ex√©cute SEULEMENT lors du premier run. Les runs suivants n'auraient PAS de filtre et chargeraient tout (r√©sultat similaire mais logique invers√©e). Mais la vraie raison est plus probablement le flag <code class="highlight">--full-refresh</code>.</li>
        </ul>

        <h3>Cas d'usage de --full-refresh :</h3>
        <p>Utilis√© pour :</p>
        <ul>
            <li>Corriger des donn√©es historiques</li>
            <li>Changer la logique du mod√®le incr√©mental</li>
            <li>R√©initialiser compl√®tement une table</li>
            <li>R√©soudre des probl√®mes de donn√©es corrompues</li>
        </ul>
        <div class="code-block">
# Run normal incr√©mental
<b>dbt run</b> --select stg_events_incremental

# Forcer un full refresh
<b>dbt run</b> --select stg_events_incremental --full-refresh
        </div>
        <p>La r√©ponse D explique le mieux pourquoi syst√©matiquement toutes les donn√©es sont recharg√©es.</p>
    </div>
</div>





<div class="q-card">
    <span class="q-head_green">QUESTION 32/65 :: MACRO USAGE IN MODELS</span>
    <span class="q-txt">You have a macro named <code>calculate_discount</code> in your <code>macros/discounts.sql</code> file:</span>
    
    <div class="code-block">
{% <span class="keyword">macro</span> calculate_discount(price, discount_pct) %}<br>
&nbsp;&nbsp;{{ price }} * (1 - {{ discount_pct }} / 100)<br>
{% <span class="keyword">endmacro</span> %}
    </div>
    
    <span class="q-txt">You want to use this macro in a model <code>order_discounts.sql</code> to compute the final discounted price. Which of the following .sql references correctly uses this macro in a select statement for a BigQuery or Snowflake warehouse?</span>
    
    <div class="opt">A.
<pre>SELECT
  order_id,
  {{ macros.calculate_discount('price', 'discount_pct') }} as final_price
FROM {{ ref('orders') }}</pre></div>
    
    <div class="opt">B.
<pre>SELECT
  order_id,
  {{ calculate_discount(price, discount_pct) }} as final_price
FROM {{ ref('orders') }}</pre></div>
    
    <div class="opt">C.
<pre>SELECT
  order_id,
  {% calculate_discount(price, discount_pct) %} as final_price
FROM {{ ref('orders') }}</pre></div>
    
    <div class="opt">D.
<pre>SELECT
  order_id,
  {{ run_query('calculate_discount(price, discount_pct)') }} as final_price
FROM {{ ref('orders') }}</pre></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Pour appeler une macro dans un mod√®le dbt, on utilise la syntaxe <code>{{ nom_macro(arguments) }}</code> avec des doubles accolades et sans pr√©fixe de namespace.</p>

        <h3>Pourquoi B est correct :</h3>
        <div class="code-block">
{{ calculate_discount(price, discount_pct) }}
        </div>
        <ul>
            <li><b>Doubles accolades {{ }} :</b> Indiquent une expression Jinja qui sera √©valu√©e et affichera un r√©sultat</li>
            <li><b>Nom direct de la macro :</b> Pas besoin de pr√©fixe <code>macros.</code></li>
            <li><b>Arguments sans quotes :</b> <code>price</code> et <code>discount_pct</code> sont des noms de colonnes, pas des strings</li>
            <li><b>R√©sultat compil√© :</b> La macro sera remplac√©e par <code>price * (1 - discount_pct / 100)</code></li>
        </ul>

        <h3>R√©sultat de la compilation :</h3>
        <div class="code-block">
<b># Avant compilation (mod√®le dbt) :</b><br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;order_id,<br>
&nbsp;&nbsp;{{ calculate_discount(price, discount_pct) }} <span class="keyword">as</span> final_price<br>
<span class="keyword">FROM</span> {{ ref('orders') }}<br>
<br>
<b># Apr√®s compilation (SQL ex√©cut√©) :</b><br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;order_id,<br>
&nbsp;&nbsp;price * (1 - discount_pct / 100) <span class="keyword">as</span> final_price<br>
<span class="keyword">FROM</span> analytics.orders
        </div>

        <h3>Pourquoi les autres sont incorrects :</h3>
        <ul>
            <li><b>A ‚ùå :</b> Avec pr√©fixe <code>macros.</code> et quotes :
                <ul>
                    <li><code>macros.</code> n'est pas n√©cessaire pour les macros du projet</li>
                    <li>Les quotes <code>'price'</code> et <code>'discount_pct'</code> transforment les colonnes en strings litt√©rales</li>
                    <li>R√©sulterait en : <code>'price' * (1 - 'discount_pct' / 100)</code> ‚Üí erreur SQL</li>
                </ul>
            </li>
            <li><b>C ‚ùå :</b> Avec <code>{% %}</code> (statement tags) :
                <ul>
                    <li><code>{% %}</code> sont des tags de statement (contr√¥le de flux, pas d'output)</li>
                    <li>Utilis√©s pour <code>if</code>, <code>for</code>, <code>set</code>, etc., pas pour afficher des valeurs</li>
                    <li>Ne produirait aucun output dans le SQL final</li>
                </ul>
            </li>
            <li><b>D ‚ùå :</b> Avec <code>run_query()</code> :
                <ul>
                    <li><code>run_query()</code> ex√©cute une requ√™te SQL pendant la compilation</li>
                    <li>N'est pas utilis√© pour appeler des macros</li>
                    <li>La syntaxe est incorrecte</li>
                </ul>
            </li>
        </ul>

        <h3>Types de d√©limiteurs Jinja :</h3>
        <div class="code-block">
<b># {{ }} ‚Üí Expressions (output/affichage) :</b><br>
{{ calculate_discount(price, discount_pct) }}<br>
<span class="comment">‚Üí √âvalue l'expression et affiche le r√©sultat</span><br>
<br>
<b># {% %} ‚Üí Statements (logique de contr√¥le) :</b><br>
{% if is_incremental() %}<br>
&nbsp;&nbsp;WHERE created_at > (SELECT MAX(created_at) FROM {{ this }})<br>
{% endif %}<br>
<span class="comment">‚Üí Contr√¥le le flux, pas d'output direct</span><br>
<br>
<b># {# #} ‚Üí Commentaires :</b><br>
{# Ceci est un commentaire Jinja #}<br>
<span class="comment">‚Üí Ignor√© pendant la compilation</span>
        </div>

        <h3>Exemple complet de macro avec mod√®le :</h3>
        <div class="code-block">
<b># macros/discounts.sql :</b><br>
{% <span class="keyword">macro</span> calculate_discount(price, discount_pct) %}<br>
&nbsp;&nbsp;{{ price }} * (1 - {{ discount_pct }} / 100)<br>
{% <span class="keyword">endmacro</span> %}<br>
<br>
{% <span class="keyword">macro</span> format_currency(amount) %}<br>
&nbsp;&nbsp;ROUND({{ amount }}, 2)<br>
{% <span class="keyword">endmacro</span> %}<br>
<br>
<b># models/order_discounts.sql :</b><br>
{{ config(materialized='table') }}<br>
<br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;order_id,<br>
&nbsp;&nbsp;customer_id,<br>
&nbsp;&nbsp;price,<br>
&nbsp;&nbsp;discount_pct,<br>
&nbsp;&nbsp;{{ calculate_discount(price, discount_pct) }} <span class="keyword">as</span> discounted_price,<br>
&nbsp;&nbsp;{{ format_currency(calculate_discount(price, discount_pct)) }} <span class="keyword">as</span> final_price_rounded<br>
<span class="keyword">FROM</span> {{ ref('orders') }}
        </div>

        <h3>Appel de macros avec diff√©rents types d'arguments :</h3>
        <div class="code-block">
<b># Colonnes simples :</b><br>
{{ calculate_discount(price, discount_pct) }}<br>
<br>
<b># Expressions SQL :</b><br>
{{ calculate_discount(price * quantity, discount_pct) }}<br>
<br>
<b># Valeurs litt√©rales :</b><br>
{{ calculate_discount(100, 20) }}  <span class="comment">‚Üí 100 * (1 - 20 / 100) = 80</span><br>
<br>
<b># Appel imbriqu√© :</b><br>
{{ format_currency(calculate_discount(price, discount_pct)) }}<br>
<br>
<b># Avec alias de colonne :</b><br>
{{ calculate_discount(base_price, discount_percentage) }} <span class="keyword">as</span> final_price
        </div>

        <h3>Macros avanc√©es avec gestion d'erreurs :</h3>
        <div class="code-block">
<b># Macro avec validation :</b><br>
{% <span class="keyword">macro</span> safe_calculate_discount(price, discount_pct) %}<br>
&nbsp;&nbsp;CASE<br>
&nbsp;&nbsp;&nbsp;&nbsp;WHEN {{ discount_pct }} < 0 THEN {{ price }}<br>
&nbsp;&nbsp;&nbsp;&nbsp;WHEN {{ discount_pct }} > 100 THEN 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;ELSE {{ price }} * (1 - {{ discount_pct }} / 100)<br>
&nbsp;&nbsp;END<br>
{% <span class="keyword">endmacro</span> %}<br>
<br>
<b># Utilisation dans un mod√®le :</b><br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;order_id,<br>
&nbsp;&nbsp;{{ safe_calculate_discount(price, discount_pct) }} <span class="keyword">as</span> safe_discounted_price<br>
<span class="keyword">FROM</span> {{ ref('orders') }}
        </div>

        <h3>Diff√©rence entre macros du projet et packages :</h3>
        <div class="code-block">
<b># Macros du projet (pas de pr√©fixe) :</b><br>
{{ calculate_discount(price, discount_pct) }}<br>
<br>
<b># Macros d'un package (avec pr√©fixe) :</b><br>
{{ dbt_utils.date_trunc('month', 'created_at') }}<br>
{{ dbt_utils.surrogate_key(['user_id', 'order_id']) }}<br>
<br>
<b># Macros globales de dbt :</b><br>
{{ ref('my_model') }}<br>
{{ source('my_source', 'my_table') }}<br>
{{ this }}
        </div>

        <h3>V√©rification de la compilation :</h3>
        <div class="code-block">
<b># Voir le SQL compil√© :</b><br>
<span class="keyword">dbt compile</span> --select order_discounts<br>
<br>
<b># Fichier g√©n√©r√© dans target/compiled :</b><br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;order_id,<br>
&nbsp;&nbsp;price * (1 - discount_pct / 100) <span class="keyword">as</span> final_price<br>
<span class="keyword">FROM</span> analytics.orders
        </div>

        <p>La r√©ponse <strong>B</strong> utilise correctement les doubles accolades pour appeler et afficher le r√©sultat de la macro avec les noms de colonnes appropri√©s.</p>
    </div>
</div>




 
		
		<div class="q-card">
            <span class="q-head_green">QUESTION 33/65 :: CUSTOM TEST LOGIC</span>
            <span class="q-txt">You want to write a custom test that checks for negative values in <b>order_total</b>. You create <b>tests/test_no_negative_order_totals.sql</b>:</span>
            <div class="code-block">
                SELECT *<br>
                FROM {{ ref('fact_orders') }}<br>
                WHERE order_total < 0
            </div>
            <span class="q-txt">What result should this query return to pass the test?</span>
            
            <div class="opt">A - Exactly one row</div>
            <div class="opt">B - Any number of rows</div>
            <div class="opt">C - No rows</div>
            <div class="opt">D - A boolean true/false value</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est C - No rows.</strong>
                <p><b>Explication : Principe fondamental des tests dbt</b></p>
                <p>Dans dbt, un test r√©ussit quand la requ√™te retourne <b>z√©ro ligne</b>.</p>
                <ul>
                    <li><b>Logique :</b> La requ√™te SQL est con√ßue pour chercher les "enregistrements probl√©matiques" (ici, les montants < 0).</li>
                    <li><b>0 lignes retourn√©es :</b> Test PASS ‚úÖ (aucun probl√®me trouv√©).</li>
                    <li><b>‚â•1 lignes retourn√©es :</b> Test FAIL ‚ùå (probl√®mes d√©tect√©s).</li>
                </ul>
                
                <p><b>Configuration :</b> On peut configurer des seuils via <code>warn_if</code> ou <code>error_if</code> dans le YAML si besoin, mais par d√©faut, dbt attend 0 r√©sultat.</p>
            </div>
        </div>

<div class="q-card">
    <span class="q-head_green">QUESTION 35/65 : TEST SELECTION BY TAG</span>
    <span class="q-txt">Your enterprise deployment has many tests. For performance reasons, in production you only want to run a subset of critical tests. You have tagged these critical tests with <code>tag:critical</code>. Which dbt command runs only critical tests?</span>
    
    <div class="opt">A. <code>dbt test --select tag:critical</code></div>
    <div class="opt">B. <code>dbt run --tag critical</code></div>
    <div class="opt">C. <code>dbt test -m source:</code></div>
    <div class="opt">D. <code>dbt test --select critical_tests</code></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : A</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Pour ex√©cuter uniquement les tests avec un tag sp√©cifique, on utilise la syntaxe de s√©lection <code>--select tag:critical</code> avec la commande <code>dbt test</code>.</p>

        <h3>Syntaxe correcte :</h3>
        <div class="code-block">
<span class="keyword">dbt test</span> --select tag:critical
        </div>
        
        <p>Cette commande :</p>
        <ul>
            <li>Ex√©cute uniquement la commande <code>test</code> (pas <code>run</code>)</li>
            <li>S√©lectionne tous les tests ayant le tag "critical"</li>
            <li>Ignore tous les autres tests</li>
        </ul>

        <h3>Comment tagger des tests :</h3>
        <div class="code-block">
<b># Dans un fichier schema.yml :</b><br>
version: 2<br>
<br>
models:<br>
&nbsp;&nbsp;- name: orders<br>
&nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: order_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- unique:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['critical']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['critical']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: customer_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- relationships:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to: ref('customers')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field: customer_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['critical', 'referential_integrity']
        </div>

        <div class="code-block">
<b># Pour des tests personnalis√©s (tests/) :</b><br>
version: 2<br>
<br>
tests:<br>
&nbsp;&nbsp;- name: test_no_negative_amounts<br>
&nbsp;&nbsp;&nbsp;&nbsp;tags: ['critical', 'financial']
        </div>

        <h3>Autres exemples de s√©lection par tag :</h3>
        <div class="code-block">
<b># Ex√©cuter tous les tests critiques :</b><br>
<span class="keyword">dbt test</span> --select tag:critical<br>
<br>
<b># Ex√©cuter les tests avec plusieurs tags :</b><br>
<span class="keyword">dbt test</span> --select tag:critical tag:financial<br>
<br>
<b># Ex√©cuter les mod√®les ET tests avec un tag :</b><br>
<span class="keyword">dbt build</span> --select tag:critical<br>
<br>
<b># Exclure certains tags :</b><br>
<span class="keyword">dbt test</span> --exclude tag:slow
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>B ‚ùå :</b> <code>dbt run --tag critical</code>
                <ul>
                    <li><code>dbt run</code> ex√©cute des mod√®les, pas des tests</li>
                    <li>La syntaxe serait <code>--select</code> pas <code>--tag</code></li>
                    <li>Ne r√©pond pas au besoin d'ex√©cuter des tests</li>
                </ul>
            </li>
            <li><b>C ‚ùå :</b> <code>dbt test -m source:</code>
                <ul>
                    <li><code>-m</code> est un alias de <code>--select</code> (valide)</li>
                    <li><code>source:</code> s√©lectionne les tests sur les sources, pas par tag</li>
                    <li>Syntaxe incompl√®te (manque le nom de la source)</li>
                </ul>
            </li>
            <li><b>D ‚ùå :</b> <code>dbt test --select critical_tests</code>
                <ul>
                    <li>Cherche un n≈ìud nomm√© "critical_tests" (nom de fichier ou mod√®le)</li>
                    <li>N'utilise pas la syntaxe de s√©lection par tag</li>
                    <li>Ne fonctionnerait que si vous aviez un test nomm√© exactement "critical_tests"</li>
                </ul>
            </li>
        </ul>

        <h3>S√©lecteurs avanc√©s pour les tests :</h3>
        <div class="code-block">
<b># Tests sur un mod√®le sp√©cifique :</b><br>
<span class="keyword">dbt test</span> --select orders<br>
<br>
<b># Tests sur un mod√®le et ses d√©pendances :</b><br>
<span class="keyword">dbt test</span> --select +orders<br>
<br>
<b># Tests avec tag critical dans le dossier staging :</b><br>
<span class="keyword">dbt test</span> --select staging,tag:critical<br>
<br>
<b># Tests de type sp√©cifique :</b><br>
<span class="keyword">dbt test</span> --select test_type:generic<br>
<span class="keyword">dbt test</span> --select test_type:singular
        </div>

        <h3>Configuration pour production :</h3>
        <div class="code-block">
<b># Dans un script CI/CD :</b><br>
<b># Production: seulement les tests critiques</b><br>
<span class="keyword">dbt test</span> --select tag:critical<br>
<br>
<b># D√©veloppement: tous les tests</b><br>
<span class="keyword">dbt test</span><br>
<br>
<b># Staging: tests critiques + tests de performance</b><br>
<span class="keyword">dbt test</span> --select tag:critical tag:performance
        </div>

        <h3>Exemple complet de strat√©gie de tagging :</h3>
        <div class="code-block">
<b># sch√©ma de tagging pour diff√©rents environnements :</b><br>
models:<br>
&nbsp;&nbsp;- name: fct_orders<br>
&nbsp;&nbsp;&nbsp;&nbsp;tags: ['core', 'daily']<br>
&nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: order_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- unique:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['critical', 'integrity']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['critical']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: amount<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- accepted_values:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values: ['USD', 'EUR', 'GBP']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['validation']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: created_at<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['critical', 'temporal']
        </div>

        <h3>Commandes CI/CD par environnement :</h3>
        <div class="code-block">
<b># Fichier .github/workflows/dbt.yml :</b><br>
name: dbt Pipeline<br>
jobs:<br>
&nbsp;&nbsp;production:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Run Critical Tests Only<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt test</span> --select tag:critical<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;staging:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Run All Non-Slow Tests<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt test</span> --exclude tag:slow<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;development:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Run All Tests<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt test</span>
        </div>

        <h3>Performance et optimisation :</h3>
        <div class="code-block">
<b># Mesurer le temps d'ex√©cution :</b><br>
<span class="keyword">time</span> dbt test --select tag:critical<br>
<span class="comment"># vs</span><br>
<span class="keyword">time</span> dbt test<br>
<br>
<b># Statistiques d'ex√©cution :</b><br>
<span class="keyword">dbt test</span> --select tag:critical --store-failures<br>
<span class="comment">‚Üí Stocke les √©checs dans une table pour analyse</span><br>
<br>
<b># Limiter le nombre de tests parall√®les :</b><br>
<span class="keyword">dbt test</span> --select tag:critical --threads 4
        </div>

        <p>La syntaxe <code>--select tag:critical</code> est la m√©thode standard pour filtrer les tests par tag dans dbt et est essentielle pour optimiser les performances en production.</p>
    </div>
</div>



        <div class="q-card">
            <span class="q-head_green">QUESTION 36/65 :: ENABLED CONFIGURATION</span>
            <span class="q-txt">You set <b>enabled: false</b> for a model in <b>dbt_project.yml</b>. What happens when you run dbt in that environment?</span>
            
            <div class="opt">A - dbt throws an error because it cannot find the model.</div>
            <div class="opt">B - dbt logs a warning but builds the model anyway.</div>
            <div class="opt">C - dbt completely skips materializing the model and any downstream model references will fail.</div>
            <div class="opt">D - dbt skips materializing the model. Any references to the disabled model cause compilation errors if directly used.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est D.</strong>
                <p><b>Explication : Comportement de enabled: false</b></p>
                <p>Lorsqu'un mod√®le est d√©sactiv√©, dbt l'ignore totalement comme s'il n'existait pas dans le projet.</p>
                <ul>
                    <li><b>Ignor√© :</b> Le mod√®le n'est ni compil√©, ni ex√©cut√© dans le warehouse.</li>
                    <li><b>Erreur de compilation :</b> Si un autre mod√®le tente de faire un <code>{{ ref('mod√®le_d√©sactiv√©') }}</code>, dbt √©chouera au parsing car il ne pourra pas r√©soudre la d√©pendance.</li>
                </ul>
                <p>C'est tr√®s utile pour d√©sactiver conditionnellement des mod√®les selon l'environnement (ex: donn√©es legacy en dev uniquement).</p>
                
            </div>
        </div>
		
		
		
		
<div class="q-card">
    <span class="q-head_green">QUESTION BIS 36/65 :: DISABLED MODELS BEHAVIOR</span>
    <span class="q-txt">You have a model <code>dim_products</code> that you do not want to build in certain environments. You set <code>enabled: false</code> in <code>dbt_project.yml</code> under the relevant environment config. What is the result when you run <code>dbt run</code> in that environment?</span>
    
    <div class="opt">A. dbt throws an error because it cannot find the model.</div>
    <div class="opt">B. dbt logs a warning but builds the model anyway.</div>
    <div class="opt">C. dbt completely skips materializing the model and any downstream model references will fail.</div>
    <div class="opt">D. dbt skips materializing the model. Any references to the disabled model cause compilation errors if directly used.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : D</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Lorsqu'un mod√®le est d√©sactiv√© avec <code>enabled: false</code>, dbt ignore compl√®tement ce mod√®le lors de la compilation et de l'ex√©cution. Cependant, si d'autres mod√®les tentent de le r√©f√©rencer avec <code>{{ ref('dim_products') }}</code>, cela g√©n√®re des erreurs de compilation.</p>

        <h3>Comportement de <code>enabled: false</code> :</h3>
        
        <div class="code-block">
<b># Configuration dans dbt_project.yml :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim_products:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: false<br>
<br>
<b># Ou configuration par environnement :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim_products:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: "{{ target.name == 'prod' }}"  <span class="comment"># D√©sactiv√© en dev</span>
        </div>

        <h3>R√©sultat :</h3>
        <ul>
            <li><b>Le mod√®le est ignor√© :</b> <code>dim_products</code> ne sera pas compil√© ni mat√©rialis√©</li>
            <li><b>Pas d'erreur initiale :</b> <code>dbt run</code> s'ex√©cute normalement (ignore simplement le mod√®le)</li>
            <li><b>Erreurs de r√©f√©rence :</b> Si un autre mod√®le contient <code>{{ ref('dim_products') }}</code>, il y aura une erreur de compilation car la r√©f√©rence ne peut pas √™tre r√©solue</li>
        </ul>

        <h3>Exemple d'erreur :</h3>
        <div class="code-block">
<b># models/marts/fct_sales.sql :</b><br>
<span class="keyword">select</span><br>
&nbsp;&nbsp;sale_id,<br>
&nbsp;&nbsp;product_id<br>
<span class="keyword">from</span> {{ ref('dim_products') }}  <span class="hl">-- ‚ùå ERREUR si dim_products est disabled</span>
        </div>

        <div class="code-block">
<b># Message d'erreur :</b><br>
Compilation Error in model fct_sales<br>
&nbsp;&nbsp;Model 'dim_products' not found or is disabled
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>A ‚ùå :</b> dbt ne lance PAS d'erreur simplement parce que le mod√®le est d√©sactiv√©. L'erreur survient seulement si quelque chose essaie de le r√©f√©rencer.</li>
            <li><b>B ‚ùå :</b> Faux, le mod√®le n'est PAS construit. <code>enabled: false</code> emp√™che compl√®tement la construction.</li>
            <li><b>C ‚ùå :</b> Partiellement correct mais incomplet. Les r√©f√©rences √©chouent avec des erreurs de compilation, pas d'ex√©cution. La distinction est importante.</li>
        </ul>

        <h3>Cas d'usage de <code>enabled:</code> :</h3>
        
        <div class="code-block">
<b># 1. D√©sactivation par environnement :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;staging:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stg_legacy_data:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: "{{ target.name in ['dev', 'qa'] }}"<br>
<br>
<b># 2. D√©sactivation conditionnelle :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;experimental:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: "{{ var('include_experimental', false) }}"<br>
<br>
<b># 3. Configuration dans le fichier mod√®le :</b><br>
<span class="comment">-- models/experimental/new_model.sql</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;enabled=false<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword">select</span> * <span class="keyword">from</span> {{ ref('source_data') }}
        </div>

        <h3>Alternatives pour g√©rer les d√©pendances :</h3>
        <p>Si vous devez d√©sactiver un mod√®le mais que d'autres en d√©pendent :</p>
        
        <div class="code-block">
<b># Option 1: Utiliser une source au lieu de ref :</b><br>
<span class="keyword">select</span> * <span class="keyword">from</span> {{ source('raw', 'products') }}<br>
<br>
<b># Option 2: V√©rifier si le mod√®le existe :</b><br>
{% if graph.nodes.get('model.my_project.dim_products') %}<br>
&nbsp;&nbsp;<span class="keyword">select</span> * <span class="keyword">from</span> {{ ref('dim_products') }}<br>
{% else %}<br>
&nbsp;&nbsp;<span class="keyword">select</span> * <span class="keyword">from</span> fallback_table<br>
{% endif %}<br>
<br>
<b># Option 3: Table de fallback conditionnelle :</b><br>
{% if target.name == 'dev' %}<br>
&nbsp;&nbsp;<span class="keyword">select</span> * <span class="keyword">from</span> dev_fallback<br>
{% else %}<br>
&nbsp;&nbsp;<span class="keyword">select</span> * <span class="keyword">from</span> {{ ref('dim_products') }}<br>
{% endif %}
        </div>

        <h3>Diagnostic d'un mod√®le d√©sactiv√© :</h3>
        <div class="code-block">
<b># V√©rifier si un mod√®le est d√©sactiv√© :</b><br>
<span class="keyword">dbt ls</span> --resource-type model --select dim_products<br>
<span class="comment"># ‚Üí Ne liste pas le mod√®le s'il est disabled</span><br>
<br>
<b># Lister tous les mod√®les (m√™me disabled) :</b><br>
<span class="keyword">dbt ls</span> --resource-type model --output json | jq '.[] | select(.name == "dim_products")'<br>
<br>
<b># V√©rifier la compilation :</b><br>
<span class="keyword">dbt compile</span> --select fct_sales<br>
<span class="comment"># ‚Üí Montre l'erreur de r√©f√©rence</span>
        </div>

        <h3>Strat√©gie pour d√©sactiver temporairement :</h3>
        <div class="code-block">
<b># Utiliser un tag pour d√©sactiver un groupe :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;experimental:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['experimental']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: "{{ not ('experimental' in (var('skip_tags', [])|list)) }}"<br>
<br>
<b># Ex√©cution en sautant les mod√®les exp√©rimentaux :</b><br>
<span class="keyword">dbt run</span> --exclude tag:experimental
        </div>

        <h3>Comparaison avec d'autres configurations :</h3>
        <div class="code-block">
<b># enabled: false (complet) :</b><br>
<span class="comment">‚Üí Mod√®le non compil√©</span><br>
<span class="comment">‚Üí R√©f√©rences √©chouent</span><br>
<span class="comment">‚Üí Pas d'output SQL</span><br>
<br>
<b># materialized: ephemeral (temporaire) :</b><br>
<span class="comment">‚Üí Mod√®le compil√© comme CTE</span><br>
<span class="comment">‚Üí R√©f√©rences fonctionnent</span><br>
<span class="comment">‚Üí Pas de table physique</span><br>
<br>
<b># +schema: none (sans schema) :</b><br>
<span class="comment">‚Üí Mod√®le compil√© et ex√©cut√©</span><br>
<span class="comment">‚Üí R√©f√©rences fonctionnent</span><br>
<span class="comment">‚Üí Pas de schema d√©di√©</span>
        </div>

        <h3>Bonnes pratiques pour <code>enabled: false</code> :</h3>
        <div class="code-block">
<b># 1. D√©sactiver les mod√®les lourds en dev :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;data_science:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: "{{ target.name == 'prod' }}"<br>
<br>
<b># 2. D√©sactiver les sources obsol√®tes :</b><br>
sources:<br>
&nbsp;&nbsp;- name: legacy_system<br>
&nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: old_table<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enabled: false<br>
<br>
<b># 3. D√©sactiver par variable :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;archive:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: "{{ var('run_archives', false) }}"
        </div>

        <h3>Migration depuis un mod√®le d√©sactiv√© :</h3>
        <div class="code-block">
<b># √âtape 1: Ajouter un fallback :</b><br>
{% if not is_model_enabled('dim_products') %}<br>
&nbsp;&nbsp;{{ log('Using fallback for dim_products', info=true) }}<br>
&nbsp;&nbsp;<span class="keyword">select</span> * <span class="keyword">from</span> {{ ref('dim_products_backup') }}<br>
{% else %}<br>
&nbsp;&nbsp;<span class="keyword">select</span> * <span class="keyword">from</span> {{ ref('dim_products') }}<br>
{% endif %}<br>
<br>
<b># Macro helper :</b><br>
{% macro is_model_enabled(model_name) %}<br>
&nbsp;&nbsp;{% set model_ref = graph.nodes.get('model.my_project.' ~ model_name) %}<br>
&nbsp;&nbsp;{% if model_ref and model_ref.config.enabled %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;true<br>
&nbsp;&nbsp;{% else %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;false<br>
&nbsp;&nbsp;{% endif %}<br>
{% endmacro %}
        </div>

        <p>La configuration <code>enabled: false</code> est un outil puissant pour contr√¥ler quels mod√®les sont construits dans diff√©rents environnements, mais il faut g√©rer attentivement les d√©pendances pour √©viter les erreurs de compilation.</p>
    </div>
</div>		
		
		
		


<div class="q-card">
    <span class="q-head_green">QUESTION 37/65 :: SEEDS PERFORMANCE OPTIMIZATION</span>
    <span class="q-txt">You place a CSV file <code>country_codes.csv</code> in <code>seeds/</code> to load reference data exactly as provided. The CSV is very large, and you want to avoid re-seeding it in every CI run. Which best practice addresses this performance concern?</span>
    
    <div class="opt">A. Convert it to ephemeral so it never physically loads.</div>
    <div class="opt">B. Use a separate command to run seeds only when truly needed (e.g., <code>dbt seed --select country_codes</code>) and skip seeds during normal CI runs.</div>
    <div class="opt">C. Move the CSV file to <code>tests/</code> so it's not recognized as a seed.</div>
    <div class="opt">D. Always run <code>dbt seed --full-refresh</code> to ensure no partial loads.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>La meilleure pratique pour g√©rer de gros fichiers seed qui changent rarement est de les ex√©cuter s√©par√©ment et de les exclure des runs CI normaux.</p>

        <h3>Strat√©gie recommand√©e :</h3>
        
        <div class="code-block">
<b># 1. Workflow CI/CD s√©par√© pour les seeds :</b><br>
<span class="comment"># .github/workflows/dbt_ci.yml</span><br>
<span class="comment"># Run normal sans seeds</span><br>
- name: Run dbt models<br>
&nbsp;&nbsp;run: <span class="keyword">dbt run</span> --exclude resource_type:seed<br>
<br>
<span class="comment"># Workflow s√©par√© pour seeds (manuel ou hebdomadaire)</span><br>
- name: Load seeds<br>
&nbsp;&nbsp;run: <span class="keyword">dbt seed</span> --select country_codes<br>
&nbsp;&nbsp;when: manual  <span class="comment"># ou schedule</span>
        </div>

        <div class="code-block">
<b># 2. Configuration dans dbt :</b><br>
seeds:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;country_codes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: true<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema: reference_data
        </div>

        <div class="code-block">
<b># 3. Ex√©cution s√©lective :</b><br>
<span class="comment"># CI normal (sans seeds)</span><br>
<span class="keyword">dbt build</span> --exclude resource_type:seed<br>
<br>
<span class="comment"># Chargement initial ou mise √† jour des seeds</span><br>
<span class="keyword">dbt seed</span> --select country_codes<br>
<br>
<span class="comment"># Ou exclure sp√©cifiquement ce seed</span><br>
<span class="keyword">dbt seed</span> --exclude country_codes
        </div>

        <h3>Avantages de cette approche :</h3>
        <ul>
            <li><b>Performance :</b> Les seeds ne sont pas recharg√©s √† chaque run</li>
            <li><b>Contr√¥le :</b> Chargement uniquement quand les donn√©es changent</li>
            <li><b>Flexibilit√© :</b> Peut √™tre ex√©cut√© manuellement ou selon un schedule</li>
            <li><b>Simplicit√© :</b> Utilise les commandes dbt standard</li>
        </ul>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>A ‚ùå :</b> Convertir en ephemeral
                <ul>
                    <li>Les seeds ne peuvent PAS √™tre √©ph√©m√©raux</li>
                    <li>√âph√©m√®re est une mat√©rialisation pour les mod√®les, pas les seeds</li>
                    <li>Les seeds cr√©ent toujours des tables physiques</li>
                </ul>
            </li>
            <li><b>C ‚ùå :</b> D√©placer vers <code>tests/</code>
                <ul>
                    <li>Le dossier <code>tests/</code> est pour les tests SQL, pas les donn√©es</li>
                    <li>Le fichier ne serait plus accessible comme seed</li>
                    <li>Mauvaise organisation du projet</li>
                </ul>
            </li>
            <li><b>D ‚ùå :</b> Toujours ex√©cuter <code>dbt seed --full-refresh</code>
                <ul>
                    <li>C'est l'OPPOS√â de ce qu'on veut faire</li>
                    <li><code>--full-refresh</code> recharge compl√®tement les donn√©es √† chaque fois</li>
                    <li>Aggrave le probl√®me de performance</li>
                </ul>
            </li>
        </ul>

        <h3>Patterns avanc√©s :</h3>
        
        <div class="code-block">
<b># 1. Seeds uniquement sur changements de fichier :</b><br>
<span class="comment"># CI avec d√©tection de changements</span><br>
- name: Check if seeds changed<br>
&nbsp;&nbsp;id: seeds-changed<br>
&nbsp;&nbsp;run: git diff --name-only HEAD~1 | grep seeds/<br>
<br>
- name: Load seeds if changed<br>
&nbsp;&nbsp;if: steps.seeds-changed.outputs.any_changed == 'true'<br>
&nbsp;&nbsp;run: <span class="keyword">dbt seed</span> --select country_codes
        </div>

        <div class="code-block">
<b># 2. Exclusion par d√©faut avec tags :</b><br>
<span class="comment"># dbt_project.yml</span><br>
seeds:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;country_codes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+tags: ['rarely_updated', 'reference']<br>
<br>
<span class="comment"># CI normal exclut les seeds rarement mis √† jour</span><br>
<span class="keyword">dbt build</span> --exclude tag:rarely_updated<br>
<br>
<span class="comment"># Mise √† jour manuelle</span><br>
<span class="keyword">dbt seed</span> --select tag:rarely_updated
        </div>

        <div class="code-block">
<b># 3. Alternative: Source externe :</b><br>
<span class="comment"># Pour de tr√®s gros fichiers de r√©f√©rence</span><br>
<span class="comment"># sources.yml</span><br>
sources:<br>
&nbsp;&nbsp;- name: reference_data<br>
&nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: country_codes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Charger depuis S3/GCS au lieu de seed</span>
        </div>

        <h3>Commandes utiles :</h3>
        <div class="code-block">
<b># Lister tous les seeds :</b><br>
<span class="keyword">dbt ls</span> --resource-type seed<br>
<br>
<b># Run sans aucun seed :</b><br>
<span class="keyword">dbt run</span> --exclude resource_type:seed<br>
<br>
<b># Build tout sauf les seeds :</b><br>
<span class="keyword">dbt build</span> --exclude resource_type:seed<br>
<br>
<b># Seed sp√©cifique :</b><br>
<span class="keyword">dbt seed</span> --select country_codes --full-refresh
        </div>

        <h3>Structure de projet optimis√©e :</h3>
        <div class="code-block">
<b># Organisation des dossiers :</b><br>
seeds/<br>
‚îú‚îÄ‚îÄ frequently_changed/       <span class="comment"># Seeds ex√©cut√©s souvent</span><br>
‚îÇ   ‚îú‚îÄ‚îÄ user_statuses.csv<br>
‚îÇ   ‚îî‚îÄ‚îÄ product_categories.csv<br>
‚îî‚îÄ‚îÄ reference_data/          <span class="comment"># Seeds rarement mis √† jour</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;‚îú‚îÄ‚îÄ country_codes.csv<br>
&nbsp;&nbsp;&nbsp;&nbsp;‚îî‚îÄ‚îÄ currency_rates.csv<br>
<br>
<b># Configuration :</b><br>
seeds:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;frequently_changed:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+tags: ['frequent']<br>
&nbsp;&nbsp;&nbsp;&nbsp;reference_data:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+tags: ['reference', 'rare']
        </div>

        <h3>Workflow CI/CD complet :</h3>
        <div class="code-block">
<b># .github/workflows/dbt.yml :</b><br>
name: dbt Pipeline<br>
on:<br>
&nbsp;&nbsp;push:<br>
&nbsp;&nbsp;&nbsp;&nbsp;branches: [main]<br>
&nbsp;&nbsp;schedule:<br>
&nbsp;&nbsp;&nbsp;&nbsp;- cron: '0 2 * * 1'  <span class="comment"># Lundi √† 2h du matin</span><br>
<br>
jobs:<br>
&nbsp;&nbsp;normal_ci:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Run models without seeds<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt build</span> --exclude tag:rare<br>
<br>
&nbsp;&nbsp;weekly_seeds:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;if: github.event_name == 'schedule'<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Load reference seeds<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt seed</span> --select tag:rare<br>
<br>
&nbsp;&nbsp;manual_seeds:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;if: github.event_name == 'workflow_dispatch'<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Manual seed update<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt seed</span> --select country_codes
        </div>

        <h3>Performance comparison :</h3>
        <div class="code-block">
<b># ‚ùå AVANT (lent) :</b><br>
dbt build  <span class="comment"># ‚Üí Inclut tous les seeds √† chaque run</span><br>
<span class="comment"># Temps: 15 minutes</span><br>
<br>
<b># ‚úÖ APR√àS (optimis√©) :</b><br>
dbt build --exclude resource_type:seed  <span class="comment"># CI normal</span><br>
<span class="comment"># Temps: 5 minutes</span><br>
<br>
dbt seed --select country_codes  <span class="comment"># Seulement quand n√©cessaire</span><br>
<span class="comment"># Temps: 10 minutes (hebdomadaire)</span>
        </div>

        <h3>Bonnes pratiques pour les seeds volumineux :</h3>
        <div class="code-block">
<b># 1. Utiliser des tags pour classification :</b><br>
seeds:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+tags:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- "{{ 'skip_in_ci' if target.name == 'ci' else 'normal' }}"<br>
<br>
<b># 2. Configuration par environnement :</b><br>
seeds:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;country_codes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: "{{ target.name != 'ci' }}"<br>
<br>
<b># 3. Variables de contr√¥le :</b><br>
seeds:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+enabled: "{{ var('run_seeds', false) }}"
        </div>

        <p>Cette approche est la meilleure pratique pour g√©rer efficacement les seeds volumineux dans les environnements CI/CD, en optimisant le temps d'ex√©cution tout en maintenant la flexibilit√©.</p>
    </div>
</div>







		
		<div class="q-card">
            <span class="q-head_green">QUESTION 37/65 :: LARGE SEEDS PERFORMANCE</span>
            <span class="q-txt">You have a very large <b>country_codes.csv</b> seed and want to avoid re-seeding it in every CI run. Which best practice addresses this?</span>
            
            <div class="opt">A - Convert it to ephemeral so it never physically loads.</div>
            <div class="opt">B - Use a separate command to run seeds only when truly needed (e.g., dbt seed --select country_codes) and skip seeds during normal CI runs.</div>
            <div class="opt">C - Move the CSV file to tests/ so it's not recognized as a seed.</div>
            <div class="opt">D - Always run dbt seed --full-refresh to ensure no partial loads.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B.</strong>
                <p><b>Explication : Gestion des seeds volumineux</b></p>
                <p>La meilleure pratique pour les fichiers qui changent rarement est de les isoler du cycle de vie standard (CI/CD) pour gagner du temps.</p>
                <ul>
                    <li><b>Workflow recommand√© :</b> Exclure les seeds des runs automatiques (<code>dbt build --exclude resource_type:seed</code>) et ne les charger que manuellement ou via un trigger sp√©cifique lors d'une modification.</li>
                    <li><b>Tags :</b> Tu peux ajouter un tag <code>rarely_updated</code> dans ton <code>dbt_project.yml</code> pour filtrer encore plus finement.</li>
                </ul>
                <p><b>Pourquoi pas A ?</b> Les seeds ne supportent pas la mat√©rialisation √©ph√©m√®re ; ils cr√©ent toujours une table physique dans le warehouse.</p>
                <div class="code-block">
                    <b>Commande CI optimale :</b><br>
                    dbt build --exclude resource_type:seed
                </div>
            </div>
        </div>

      
	  
	 
<div class="q-card">
    <span class="q-head_green">QUESTION 38/65 :: MODULAR REFACTORING IN DBT</span>
    <span class="q-txt">You inherit a 300-line monolithic SQL script that joins 8 different source tables, applies transformations, and produces final columns for a BI dashboard. You want to conform to dbt best practices. How would you refactor this script using dbt's modular approach?</span>
    
    <div class="opt">A. Extract each source table's cleaning/renaming steps into staging models (e.g., <code>stg_orders</code>, <code>stg_users</code>) so they can each be tested or reused.</div>
    <div class="opt">B. Potentially use ephemeral or view materialization for these staging layers.</div>
    <div class="opt">C. Create intermediate or fact/dim models to handle the joins or transformations.</div>
    <div class="opt">D. Reference these staging or intermediate models in a final "dashboard" model, using <code>ref()</code>.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponses correctes : A, B, C, D (TOUTES les r√©ponses)</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Cette question illustre les meilleures pratiques de modularit√© dans dbt. Le refactoring d'un script SQL monolithique suit le principe de s√©paration des pr√©occupations et permet une meilleure maintenabilit√©, testabilit√© et r√©utilisation.</p>

        <h3>Option A : Mod√®les de staging</h3>
        <p>Extraire chaque table source dans un mod√®le de staging qui effectue les t√¢ches de nettoyage et de renommage de base.</p>
        
        <div class="code-block">
<b># AVANT (dans le script monolithique) :</b><br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;o.id <span class="keyword">as</span> order_id,<br>
&nbsp;&nbsp;LOWER(u.email) <span class="keyword">as</span> user_email,<br>
&nbsp;&nbsp;CAST(p.price <span class="keyword">as</span> DECIMAL(10,2)) <span class="keyword">as</span> price<br>
<span class="keyword">FROM</span> raw.orders o<br>
<span class="keyword">JOIN</span> raw.users u <span class="keyword">ON</span> o.user_id = u.id<br>
<span class="keyword">JOIN</span> raw.products p <span class="keyword">ON</span> o.product_id = p.id<br>
<span class="comment">-- 300 lignes de transformations complexes...</span><br>
<br>
<b># APR√àS (mod√®les staging) :</b><br>
<span class="comment">-- models/staging/stg_orders.sql</span><br>
{{ config(materialized='view') }}<br>
<br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;id <span class="keyword">as</span> order_id,<br>
&nbsp;&nbsp;user_id,<br>
&nbsp;&nbsp;product_id,<br>
&nbsp;&nbsp;status,<br>
&nbsp;&nbsp;created_at<br>
<span class="keyword">FROM</span> {{ source('raw', 'orders') }}<br>
<span class="keyword">WHERE</span> status <span class="keyword">IS NOT</span> NULL<br>
<br>
<span class="comment">-- models/staging/stg_users.sql</span><br>
{{ config(materialized='view') }}<br>
<br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;id <span class="keyword">as</span> user_id,<br>
&nbsp;&nbsp;LOWER(email) <span class="keyword">as</span> email,<br>
&nbsp;&nbsp;country<br>
<span class="keyword">FROM</span> {{ source('raw', 'users') }}
        </div>

        <h3>Option B : Mat√©rialisation √©phem√®re ou vue</h3>
        <p>Utiliser <code>view</code> ou <code>ephemeral</code> pour les couches staging afin d'√©viter de stocker des donn√©es interm√©diaires inutilement.</p>
        
        <div class="code-block">
<b># Materialized as VIEW (l√©ger, toujours √† jour) :</b><br>
{{ config(materialized='view') }}<br>
<span class="comment">‚Üí Pas de stockage physique suppl√©mentaire</span><br>
<span class="comment">‚Üí Recr√©√© √† chaque ex√©cution</span><br>
<span class="comment">‚Üí Bon pour les petites tables fr√©quemment mises √† jour</span><br>
<br>
<b># Materialized as EPHEMERAL (CTE) :</b><br>
{{ config(materialized='ephemeral') }}<br>
<span class="comment">‚Üí Pas de table/view cr√©√©e dans la base</span><br>
<span class="comment">‚Üí La logique est inject√©e comme CTE dans les mod√®les d√©pendants</span><br>
<span class="comment">‚Üí Parfait pour les transformations r√©utilisables</span><br>
<br>
<b># Mat√©rialisation recommand√©e par couche :</b><br>
<span class="comment">staging/    ‚Üí view ou ephemeral</span><br>
<span class="comment">intermediate/ ‚Üí view ou table (selon la taille)</span><br>
<span class="comment">marts/      ‚Üí table (pour la performance)</span>
        </div>

        <h3>Option C : Mod√®les interm√©diaires ou fact/dim</h3>
        <p>Cr√©er des mod√®les interm√©diaires pour les jointures complexes et des mod√®les finaux de type fait/dimension.</p>
        
        <div class="code-block">
<b># Mod√®le interm√©diaire (int_) :</b><br>
<span class="comment">-- models/intermediate/int_order_details.sql</span><br>
{{ config(materialized='table') }}<br>
<br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;o.order_id,<br>
&nbsp;&nbsp;o.status,<br>
&nbsp;&nbsp;u.user_id,<br>
&nbsp;&nbsp;u.email,<br>
&nbsp;&nbsp;p.product_name,<br>
&nbsp;&nbsp;p.price<br>
<span class="keyword">FROM</span> {{ ref('stg_orders') }} o<br>
<span class="keyword">JOIN</span> {{ ref('stg_users') }} u <span class="keyword">ON</span> o.user_id = u.user_id<br>
<span class="keyword">JOIN</span> {{ ref('stg_products') }} p <span class="keyword">ON</span> o.product_id = p.product_id<br>
<br>
<b># Mod√®le de fait (fct_) :</b><br>
<span class="comment">-- models/marts/fct_orders.sql</span><br>
{{ config(materialized='table') }}<br>
<br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;order_id,<br>
&nbsp;&nbsp;user_id,<br>
&nbsp;&nbsp;SUM(price) <span class="keyword">as</span> total_amount,<br>
&nbsp;&nbsp;COUNT(*) <span class="keyword">as</span> item_count<br>
<span class="keyword">FROM</span> {{ ref('int_order_details') }}<br>
<span class="keyword">GROUP BY</span> 1, 2
        </div>

        <h3>Option D : Mod√®le final avec ref()</h3>
        <p>Utiliser <code>ref()</code> pour cr√©er des d√©pendances explicites entre les mod√®les, ce qui permet √† dbt de construire le DAG correctement.</p>
        
        <div class="code-block">
<b># Mod√®le final pour dashboard :</b><br>
<span class="comment">-- models/marts/dashboard_final.sql</span><br>
{{ config(materialized='table') }}<br>
<br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;f.order_id,<br>
&nbsp;&nbsp;d.order_date,<br>
&nbsp;&nbsp;c.customer_name,<br>
&nbsp;&nbsp;f.total_amount,<br>
&nbsp;&nbsp;p.product_category,<br>
&nbsp;&nbsp;{{ dbt_utils.surrogate_key(['f.order_id', 'd.order_date']) }} <span class="keyword">as</span> dashboard_key<br>
<span class="keyword">FROM</span> {{ ref('fct_orders') }} f<br>
<span class="keyword">JOIN</span> {{ ref('dim_dates') }} d <span class="keyword">ON</span> DATE(f.created_at) = d.date<br>
<span class="keyword">JOIN</span> {{ ref('dim_customers') }} c <span class="keyword">ON</span> f.user_id = c.user_id<br>
<span class="keyword">JOIN</span> {{ ref('dim_products') }} p <span class="keyword">ON</span> f.product_id = p.product_id<br>
<span class="keyword">WHERE</span> f.status = 'completed'
        </div>

        <h3>Architecture dbt recommand√©e :</h3>
        <div class="code-block">
<b># Structure de projet modulaire :</b><br>
models/<br>
‚îú‚îÄ‚îÄ staging/           <span class="comment"># A. Mod√®les de base</span><br>
‚îÇ   ‚îú‚îÄ‚îÄ stg_orders.sql<br>
‚îÇ   ‚îú‚îÄ‚îÄ stg_users.sql<br>
‚îÇ   ‚îî‚îÄ‚îÄ stg_products.sql<br>
‚îú‚îÄ‚îÄ intermediate/      <span class="comment"># C. Jointures et transformations</span><br>
‚îÇ   ‚îú‚îÄ‚îÄ int_order_details.sql<br>
‚îÇ   ‚îî‚îÄ‚îÄ int_user_behavior.sql<br>
‚îî‚îÄ‚îÄ marts/            <span class="comment"># C. Mod√®les finaux + D. Dashboard</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;‚îú‚îÄ‚îÄ fct_orders.sql<br>
&nbsp;&nbsp;&nbsp;&nbsp;‚îú‚îÄ‚îÄ dim_customers.sql<br>
&nbsp;&nbsp;&nbsp;&nbsp;‚îî‚îÄ‚îÄ dashboard_final.sql
        </div>

        <h3>Avantages du refactoring modulaire :</h3>
        <div class="code-block">
<b># 1. Testabilit√© :</b><br>
<span class="comment">-- schema.yml</span><br>
models:<br>
&nbsp;&nbsp;- name: stg_orders<br>
&nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: order_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- unique<br>
<br>
<b># 2. R√©utilisation :</b><br>
<span class="comment">-- Plusieurs mod√®les peuvent utiliser stg_orders</span><br>
{{ ref('stg_orders') }}  <span class="comment">‚Üí Utilis√© dans 5 mod√®les diff√©rents</span><br>
<br>
<b># 3. DAG clair :</b><br>
<span class="keyword">dbt docs generate</span><br>
<span class="comment">‚Üí Visualisation des d√©pendances</span><br>
<span class="comment">‚Üí Compr√©hension du flux de donn√©es</span>
        </div>

        <h3>Transformation √©tape par √©tape :</h3>
        <div class="code-block">
<b># √âTAPE 1: Extraire les sources en staging (A + B) :</b><br>
stg_raw_data.sql<br>
‚Üì<br>
stg_cleaned_data.sql<br>
<br>
<b># √âTAPE 2: Cr√©er des transformations interm√©diaires (C) :</b><br>
int_joined_data.sql<br>
‚Üì<br>
int_aggregated_data.sql<br>
<br>
<b># √âTAPE 3: Construire les marts finaux (C) :</b><br>
fct_sales.sql<br>
dim_customers.sql<br>
<br>
<b># √âTAPE 4: Assembler pour le dashboard (D) :</b><br>
dashboard_final.sql  <span class="comment">‚Üí Utilise ref() pour toutes les d√©pendances</span>
        </div>

        <h3>Exemple de configuration par couche :</h3>
        <div class="code-block">
<b># dbt_project.yml :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;staging:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+materialized: view<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+schema: staging<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+tags: ['staging']<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;intermediate:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+materialized: table<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+schema: intermediate<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+tags: ['intermediate']<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+materialized: table<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+schema: analytics<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+tags: ['marts']
        </div>

        <h3>Workflow de d√©veloppement :</h3>
        <div class="code-block">
<b># 1. Tester chaque couche ind√©pendamment :</b><br>
<span class="keyword">dbt run</span> --select staging<br>
<span class="keyword">dbt test</span> --select staging<br>
<br>
<b># 2. Construire progressivement :</b><br>
<span class="keyword">dbt run</span> --select staging+<br>
<span class="comment">‚Üí Ex√©cute staging et ses d√©pendants</span><br>
<br>
<b># 3. Documentation automatique :</b><br>
<span class="keyword">dbt docs generate</span><br>
<span class="keyword">dbt docs serve</span><br>
<span class="comment">‚Üí Voir le DAG complet</span>
        </div>

        <h3>Pourquoi TOUTES les options sont correctes :</h3>
        <ul>
            <li><b>A :</b> Cr√©e des modules testables et r√©utilisables</li>
            <li><b>B :</b> Optimise les performances et la flexibilit√©</li>
            <li><b>C :</b> S√©pare les pr√©occupations logiques</li>
            <li><b>D :</b> √âtablit des d√©pendances explicites et un DAG clair</li>
        </ul>

        <h3>R√©sultat final :</h3>
        <div class="code-block">
<b># ‚ùå AVANT :</b><br>
1 script SQL de 300 lignes<br>
0 tests unitaires<br>
Difficile √† maintenir<br>
Pas de r√©utilisation<br>
<br>
<b># ‚úÖ APR√àS :</b><br>
15 mod√®les dbt organis√©s<br>
Tests sur chaque colonne cl√©<br>
DAG visuel clair<br>
R√©utilisation maximale<br>
Performance optimis√©e
        </div>

        <p>Ce refactoring suit les meilleures pratiques dbt en cr√©ant une architecture modulaire, testable et maintenable qui transforme un script monolithique en un pipeline de donn√©es robuste et √©volutif.</p>
    </div>
</div>
		
		
		
		






<div class="q-card">
    <span class="q-head_green">QUESTION 39/65 :: AUTOMATIC GRANTS WITH POST-HOOKS</span>
    <span class="q-txt">In production, each newly created table must grant SELECT privileges to <code>analyst_role</code>. You want dbt to handle this automatically. Which dbt feature implements this logic?</span>
    
    <div class="opt">A. A post-hook in <code>dbt_project.yml</code> or at the model level that runs <code>GRANT SELECT</code> after table creation.</div>
    <div class="opt">B. Define ephemeral so no table is physically created.</div>
    <div class="opt">C. Use <code>dbt run-operation test_grant_permissions</code>.</div>
    <div class="opt">D. Hard-code the role in your .sql file.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : A</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Les <code>post-hooks</code> sont la fonctionnalit√© dbt con√ßue sp√©cifiquement pour ex√©cuter du SQL automatiquement apr√®s la cr√©ation d'un mod√®le. C'est la solution id√©ale pour g√©rer les permissions de mani√®re automatique et centralis√©e.</p>

        <h3>Configuration avec post-hook :</h3>
        
        <div class="code-block">
<b># 1. Configuration globale dans dbt_project.yml :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+post-hook:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- "grant select on {{ this }} to role analyst_role"<br>
<br>
<span class="comment"># Cette configuration s'applique √† tous les mod√®les du projet</span>
        </div>

        <div class="code-block">
<b># 2. Configuration par dossier :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+post-hook:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- "grant select on {{ this }} to role analyst_role"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- "grant select on {{ this }} to role reporting_role"
        </div>

        <div class="code-block">
<b># 3. Configuration au niveau du mod√®le :</b><br>
<span class="comment">-- models/marts/fct_sales.sql</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;materialized='table',<br>
&nbsp;&nbsp;&nbsp;&nbsp;post_hook=[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"grant select on {{ this }} to role analyst_role",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"grant select on {{ this }} to role bi_tool_role"<br>
&nbsp;&nbsp;&nbsp;&nbsp;]<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword">select</span> * <span class="keyword">from</span> {{ ref('stg_orders') }}
        </div>

        <h3>Syntaxe avec Jinja pour plus de flexibilit√© :</h3>
        <div class="code-block">
<b># Condition par environnement :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+post-hook:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- "{% if target.name == 'prod' %}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"grant select on {{ this }} to role analyst_role"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{% endif %}"
        </div>

        <div class="code-block">
<b># Macro r√©utilisable :</b><br>
<span class="comment">-- macros/grant_select.sql</span><br>
{% <span class="keyword">macro</span> grant_select_to_analysts() %}<br>
&nbsp;&nbsp;{% if target.name == 'prod' %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;grant select on {{ this }} to role analyst_role;<br>
&nbsp;&nbsp;&nbsp;&nbsp;grant select on {{ this }} to role reporting_role;<br>
&nbsp;&nbsp;{% endif %}<br>
{% <span class="keyword">endmacro</span> %}<br>
<br>
<span class="comment"># dbt_project.yml</span><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+post-hook: "{{ grant_select_to_analysts() }}"
        </div>

        <h3>Ordre d'ex√©cution avec hooks :</h3>
        <div class="code-block">
<b># S√©quence d'ex√©cution :</b><br>
1. <span class="hl">pre-hook</span>: Avant la construction du mod√®le<br>
2. Construction du mod√®le (CREATE/INSERT)<br>
3. <span class="hl">post-hook</span>: Apr√®s la construction du mod√®le ‚úÖ <span class="comment">(pour GRANT)</span>
        </div>

        <h3>Exemple complet avec logging :</h3>
        <div class="code-block">
<span class="comment">-- macros/apply_grants.sql</span><br>
{% <span class="keyword">macro</span> apply_grants() %}<br>
&nbsp;&nbsp;{% if target.name == 'prod' %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{% set grants = [<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"grant select on " ~ this ~ " to role analyst_role",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"grant select on " ~ this ~ " to role reporting_role"<br>
&nbsp;&nbsp;&nbsp;&nbsp;] %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;{% for grant_sql in grants %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{ log("Applying: " ~ grant_sql, info=true) }}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{ grant_sql }};<br>
&nbsp;&nbsp;&nbsp;&nbsp;{% endfor %}<br>
&nbsp;&nbsp;{% endif %}<br>
{% <span class="keyword">endmacro</span> %}
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>B ‚ùå :</b> Define ephemeral
                <ul>
                    <li>Ephemeral ne cr√©e PAS de table physique</li>
                    <li>Pas de table = pas besoin de permissions</li>
                    <li>Ne r√©sout pas le probl√®me pour les tables r√©elles</li>
                </ul>
            </li>
            <li><b>C ‚ùå :</b> Use <code>dbt run-operation test_grant_permissions</code>
                <ul>
                    <li><code>run-operation</code> est pour ex√©cuter des macros manuellement</li>
                    <li>Pas automatique apr√®s chaque cr√©ation de table</li>
                    <li>N√©cessite une intervention manuelle</li>
                </ul>
            </li>
            <li><b>D ‚ùå :</b> Hard-code in .sql file
                <ul>
                    <li>Pas automatique</li>
                    <li>Non maintenable (r√©p√©tition dans chaque mod√®le)</li>
                    <li>Viole le principe DRY</li>
                    <li>Difficile √† modifier globalement</li>
                </ul>
            </li>
        </ul>

        <h3>Configuration avanc√©e par environnement :</h3>
        <div class="code-block">
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+post-hook:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- "{% if target.name == 'prod' %}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"grant select on {{ this }} to role analyst_role"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{% elif target.name == 'dev' %}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"grant select on {{ this }} to role dev_role"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{% endif %}"
        </div>

        <h3>Avec grants multiples via macro :</h3>
        <div class="code-block">
{% <span class="keyword">macro</span> grant_to_multiple_roles(roles) %}<br>
&nbsp;&nbsp;{% for role in roles %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;grant select on {{ this }} to role {{ role }};<br>
&nbsp;&nbsp;{% endfor %}<br>
{% <span class="keyword">endmacro</span> %}<br>
<br>
<span class="comment"># dbt_project.yml</span><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+post-hook: "{{ grant_to_multiple_roles(['analyst_role', 'bi_role', 'dashboard_role']) }}"
        </div>

        <h3>Alternative native avec grants (dbt v1.2+) :</h3>
        <div class="code-block">
<b># Configuration native plus simple :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+grants:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select: ['analyst_role', 'reporting_role']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insert: ['etl_role']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;update: ['admin_role']<br>
<br>
<b># Au niveau du mod√®le :</b><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;materialized='table',<br>
&nbsp;&nbsp;&nbsp;&nbsp;grants={<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'select': ['analyst_role', 'bi_role'],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'insert': ['etl_role']<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;)<br>
}}
        </div>

        <h3>Comparaison des approches :</h3>
        <div class="code-block">
<b># POST-HOOKS (universel) :</b><br>
<span class="hl">+ Compatible toutes versions dbt</span><br>
<span class="hl">+ Tr√®s flexible (Jinja complet)</span><br>
<span class="hl">+ Compatible tous data warehouses</span><br>
<span class="hl">- Plus verbeux que grants natifs</span><br>
<br>
<b># GRANTS NATIFS (dbt v1.2+) :</b><br>
<span class="hl">+ Syntaxe plus simple</span><br>
<span class="hl">+ Int√©gr√© au c≈ìur de dbt</span><br>
<span class="hl">- Non r√©trocompatible</span><br>
<span class="hl">- Moins flexible</span>
        </div>

        <h3>Ex√©cution des hooks dans dbt :</h3>
        <div class="code-block">
<b># Voir les hooks dans le SQL compil√© :</b><br>
<span class="keyword">dbt compile</span> --select my_model<br>
<br>
<b># Fichier target/compiled/my_model.sql :</b><br>
<span class="comment">-- pre-hook (avant)</span><br>
{{ pre_hook_statements }}<br>
<br>
CREATE TABLE my_model AS (<br>
&nbsp;&nbsp;SELECT * FROM ...<br>
);<br>
<br>
<span class="comment">-- post-hook (apr√®s)</span><br>
GRANT SELECT ON my_model TO analyst_role;<br>
GRANT SELECT ON my_model TO reporting_role;
        </div>

        <h3>Bonnes pratiques pour les grants :</h3>
        <div class="code-block">
<b># 1. Utiliser des macros centralis√©es :</b><br>
{% <span class="keyword">macro</span> production_grants() %}<br>
&nbsp;&nbsp;{% if target.name == 'prod' %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{{ adapter.dispatch('apply_grants')() }}<br>
&nbsp;&nbsp;{% endif %}<br>
{% <span class="keyword">endmacro</span> %}<br>
<br>
<b># 2. Gestion par sch√©ma :</b><br>
{% <span class="keyword">macro</span> grants_by_schema() %}<br>
&nbsp;&nbsp;{% if this.schema == 'analytics' %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;grant select on {{ this }} to role analyst_role;<br>
&nbsp;&nbsp;{% elif this.schema == 'staging' %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;grant select on {{ this }} to role etl_role;<br>
&nbsp;&nbsp;{% endif %}<br>
{% <span class="keyword">endmacro</span> %}
        </div>

        <h3>Int√©gration CI/CD :</h3>
        <div class="code-block">
<b># .github/workflows/dbt.yml :</b><br>
name: dbt Production Deploy<br>
on:<br>
&nbsp;&nbsp;push:<br>
&nbsp;&nbsp;&nbsp;&nbsp;branches: [main]<br>
<br>
jobs:<br>
&nbsp;&nbsp;deploy:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;env:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBT_PROFILES_DIR: ./profiles<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Run dbt with automatic grants<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt run</span> --target prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Les post-hooks s'ex√©cutent automatiquement</span>
        </div>

        <h3>D√©pannage des hooks :</h3>
        <div class="code-block">
<b># V√©rifier si les hooks s'ex√©cutent :</b><br>
<span class="keyword">dbt run</span> --select my_model --debug<br>
<br>
<b># Logs d'ex√©cution :</b><br>
14:30:25  Running with dbt=1.6.0<br>
14:30:26  1 of 1 START sql table model analytics.my_model<br>
14:30:27  Applying: grant select on analytics.my_model to role analyst_role<br>
14:30:28  1 of 1 OK created sql table model analytics.my_model<br>
<br>
<b># V√©rifier les permissions dans la base :</b><br>
<span class="keyword">SHOW</span> GRANTS ON TABLE analytics.my_model;
        </div>

        <p>Les <code>post-hooks</code> sont la m√©thode standard et recommand√©e pour automatiser les permissions dans dbt. Ils permettent d'ex√©cuter du SQL conditionnel apr√®s la cr√©ation de chaque mod√®le, garantissant que les r√¥les appropri√©s ont toujours acc√®s aux donn√©es.</p>
    </div>
</div>		
	  
	  
	  




<div class="q-card">
    <span class="q-head_green">QUESTION 40/65 :: LATE-ARRIVING DATA HANDLING</span>
    <span class="q-txt">In your BigQuery incremental model <code>fct_payments</code> appends new payment records daily. However, your payments source occasionally sends late-arriving data for old dates (e.g., last month). You want dbt to reprocess a small date window to catch updates without reloading the entire table daily. Which snippet best addresses this?</span>
    
    <div class="opt">A.
<pre>SELECT * FROM source_table
{% if is_incremental() %}
  WHERE payment_date >= date_sub(DATE('{{ var('report_date') }}'), INTERVAL 1 DAY)
{% endif %}</pre></div>
    
    <div class="opt">B.
<pre>{% if is_incremental() %}
  SELECT * FROM source_table
  WHERE payment_date >= '2020-01-01'
{% else %}
  SELECT * FROM source_table
{% endif %}</pre></div>
    
    <div class="opt">C.
<pre>{% if is_incremental() %}
  /* merges entire data set every run */
  SELECT * FROM source_table
{% else %}
  SELECT * FROM source_table
{% endif %}</pre></div>
    
    <div class="opt">D.
<pre>SELECT * FROM source_table
WHERE payment_date >= current_date</pre></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : A</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Pour g√©rer les <b>late-arriving data</b> (donn√©es arrivant tardivement), la meilleure approche est de retraiter une fen√™tre de dates glissante en mode incr√©mental. L'option A utilise une variable dynamique avec un intervalle pour capturer les nouvelles donn√©es ET les mises √† jour r√©centes.</p>

        <h3>Pourquoi A est la meilleure solution :</h3>
        <div class="code-block">
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> source_table<br>
{% if is_incremental() %}<br>
&nbsp;&nbsp;<span class="keyword">WHERE</span> payment_date >= date_sub(DATE('{{ var('report_date') }}'), <span class="keyword">INTERVAL</span> 1 DAY)<br>
{% endif %}
        </div>
        
        <p><b>Avantages :</b></p>
        <ul>
            <li><b>Fen√™tre glissante dynamique :</b> Utilise une variable <code>report_date</code> pour contr√¥ler la date de r√©f√©rence</li>
            <li><b>Buffer d'un jour :</b> <code>INTERVAL 1 DAY</code> capture les donn√©es tardives du jour pr√©c√©dent</li>
            <li><b>Flexible :</b> La fen√™tre peut √™tre ajust√©e (1 jour, 7 jours, 30 jours selon les besoins)</li>
            <li><b>√âvite full refresh :</b> Ne recharge pas toute la table</li>
        </ul>

        <h3>Configuration compl√®te avec strat√©gie de merge :</h3>
        <div class="code-block">
<span class="comment">-- models/marts/fct_payments.sql</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;materialized='incremental',<br>
&nbsp;&nbsp;&nbsp;&nbsp;unique_key='payment_id',<br>
&nbsp;&nbsp;&nbsp;&nbsp;on_schema_change='merge_existing_columns',<br>
&nbsp;&nbsp;&nbsp;&nbsp;merge_update_columns=['payment_status', 'updated_at']<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword">select</span><br>
&nbsp;&nbsp;payment_id,<br>
&nbsp;&nbsp;customer_id,<br>
&nbsp;&nbsp;payment_date,<br>
&nbsp;&nbsp;payment_amount,<br>
&nbsp;&nbsp;payment_status,<br>
&nbsp;&nbsp;current_timestamp() <span class="keyword">as</span> updated_at<br>
<span class="keyword">from</span> {{ source('payments', 'raw_payments') }}<br>
<br>
{% if is_incremental() %}<br>
&nbsp;&nbsp;<span class="comment">-- Capture nouvelles donn√©es + donn√©es tardives des 7 derniers jours</span><br>
&nbsp;&nbsp;<span class="keyword">where</span> payment_date >= date_sub(DATE('{{ var('report_date', run_started_at.strftime('%Y-%m-%d')) }}'), <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">INTERVAL</span> 7 DAY)<br>
{% endif %}
        </div>

        <h3>Utilisation avec diff√©rentes fen√™tres :</h3>
        <div class="code-block">
<b># Fen√™tre de 1 jour (donn√©es tr√®s r√©centes) :</b><br>
<span class="keyword">dbt run</span> --vars '{"report_date": "2024-01-15", "lookback_days": 1}'<br>
<br>
<b># Fen√™tre de 30 jours (pour corriger beaucoup de donn√©es tardives) :</b><br>
<span class="keyword">dbt run</span> --vars '{"report_date": "2024-01-15", "lookback_days": 30}'<br>
<br>
<b># Version avec variable par d√©faut :</b><br>
<span class="keyword">dbt run</span> --select fct_payments<br>
<span class="comment">‚Üí Utilise les valeurs par d√©faut configur√©es</span>
        </div>

        <h3>Version plus flexible :</h3>
        <div class="code-block">
{% if is_incremental() %}<br>
&nbsp;&nbsp;<span class="keyword">where</span> payment_date >= date_sub(<br>
&nbsp;&nbsp;&nbsp;&nbsp;DATE('{{ var('report_date', run_started_at.strftime('%Y-%m-%d')) }}'),<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">INTERVAL</span> {{ var('lookback_days', 7) }} DAY<br>
&nbsp;&nbsp;)<br>
{% endif %}
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>B ‚ùå :</b> Date fixe '2020-01-01'
                <div class="code-block">
<span class="keyword">WHERE</span> payment_date >= '2020-01-01'<br>
<span class="comment">‚Üí Date fixe, pas dynamique</span><br>
<span class="comment">‚Üí Va retraiter TOUTES les donn√©es depuis 2020</span><br>
<span class="comment">‚Üí Perd l'avantage de l'incr√©mental</span><br>
<span class="comment">‚Üí Performance tr√®s mauvaise</span>
                </div>
            </li>
            <li><b>C ‚ùå :</b> Merge entire dataset
                <div class="code-block">
<span class="comment">/* merges entire data set every run */</span><br>
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> source_table<br>
<span class="comment">‚Üí Recharge TOUTES les donn√©es √† chaque run</span><br>
<span class="comment">‚Üí Exactement ce qu'on veut √©viter</span><br>
<span class="comment">‚Üí Aucun filtre de date</span><br>
<span class="comment">‚Üí Performance catastrophique</span>
                </div>
            </li>
            <li><b>D ‚ùå :</b> <code>current_date</code> seulement
                <div class="code-block">
<span class="keyword">WHERE</span> payment_date >= current_date<br>
<span class="comment">‚Üí Ne capture QUE les donn√©es du jour en cours</span><br>
<span class="comment">‚Üí Manque les donn√©es tardives des jours pr√©c√©dents</span><br>
<span class="comment">‚Üí Ne r√©sout pas le probl√®me des late-arriving data</span>
                </div>
            </li>
        </ul>

        <h3>Strat√©gie avanc√©e avec delete+insert :</h3>
        <p>Pour BigQuery, on peut aussi utiliser une strat√©gie de suppression puis insertion :</p>
        
        <div class="code-block">
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;materialized='incremental',<br>
&nbsp;&nbsp;&nbsp;&nbsp;incremental_strategy='delete+insert',<br>
&nbsp;&nbsp;&nbsp;&nbsp;unique_key='payment_date'<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword">select</span> * <span class="keyword">from</span> {{ source('payments', 'raw_payments') }}<br>
<br>
{% if is_incremental() %}<br>
&nbsp;&nbsp;<span class="keyword">where</span> payment_date >= date_sub(current_date(), <span class="keyword">INTERVAL</span> 7 DAY)<br>
{% endif %}
        </div>

        <p>Cette approche :</p>
        <ul>
            <li>Supprime les enregistrements des 7 derniers jours</li>
            <li>Les recharge compl√®tement</li>
            <li>Corrige automatiquement les late-arriving data</li>
        </ul>

        <h3>Monitoring des late-arriving data :</h3>
        <div class="code-block">
<span class="comment">-- Test pour d√©tecter les late-arriving data</span><br>
<span class="keyword">with</span> late_arrivals <span class="keyword">as</span> (<br>
&nbsp;&nbsp;<span class="keyword">select</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;payment_date,<br>
&nbsp;&nbsp;&nbsp;&nbsp;count(*) <span class="keyword">as</span> late_count<br>
&nbsp;&nbsp;<span class="keyword">from</span> {{ ref('fct_payments') }}<br>
&nbsp;&nbsp;<span class="keyword">where</span> updated_at > payment_date + <span class="keyword">interval</span> 1 day<br>
&nbsp;&nbsp;<span class="keyword">group by</span> 1<br>
)<br>
<br>
<span class="keyword">select</span> * <span class="keyword">from</span> late_arrivals<br>
<span class="keyword">where</span> late_count > 0
        </div>

        <h3>Impl√©mentation avec hooks pour la validation :</h3>
        <div class="code-block">
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;materialized='incremental',<br>
&nbsp;&nbsp;&nbsp;&nbsp;unique_key='payment_id',<br>
&nbsp;&nbsp;&nbsp;&nbsp;post_hook=[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"{{ validate_late_arrivals() }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;]<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="comment">-- macros/validate_late_arrivals.sql</span><br>
{% <span class="keyword">macro</span> validate_late_arrivals() %}<br>
&nbsp;&nbsp;{% if is_incremental() %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{% set check_query %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">SELECT</span> COUNT(*) <span class="keyword">as</span> late_count<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">FROM</span> {{ this }}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">WHERE</span> updated_at > payment_date + <span class="keyword">INTERVAL</span> 7 DAY<br>
&nbsp;&nbsp;&nbsp;&nbsp;{% endset %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;{% set results = run_query(check_query) %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{% if results and results[0][0] > 0 %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{ log('‚ö†Ô∏è Late-arriving data detected: ' ~ results[0][0] ~ ' records', info=true) }}<br>
&nbsp;&nbsp;&nbsp;&nbsp;{% endif %}<br>
&nbsp;&nbsp;{% endif %}<br>
{% <span class="keyword">endmacro</span> %}
        </div>

        <h3>Configuration dans dbt_project.yml :</h3>
        <div class="code-block">
<b># Variables par d√©faut pour tous les mod√®les :</b><br>
vars:<br>
&nbsp;&nbsp;lookback_days: 7  <span class="comment"># Fen√™tre de retraitement par d√©faut</span><br>
&nbsp;&nbsp;report_date: "{{ run_started_at.strftime('%Y-%m-%d') }}"<br>
<br>
<b># Configuration sp√©cifique pour fct_payments :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fct_payments:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+vars:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lookback_days: 3  <span class="comment"># Fen√™tre plus courte pour payments</span>
        </div>

        <h3>Workflow CI/CD pour g√©rer les late-arriving data :</h3>
        <div class="code-block">
<b># .github/workflows/dbt.yml :</b><br>
name: dbt Pipeline<br>
on:<br>
&nbsp;&nbsp;schedule:<br>
&nbsp;&nbsp;&nbsp;&nbsp;- cron: '0 2 * * *'  <span class="comment"># 2h du matin tous les jours</span><br>
<br>
jobs:<br>
&nbsp;&nbsp;daily_incremental:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Run incremental with 7-day lookback<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt run</span> --select fct_payments --vars '{"lookback_days": 7}'<br>
<br>
&nbsp;&nbsp;weekly_backfill:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;if: github.event_name == 'schedule' && github.event.schedule == '0 2 * * 0'<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Weekly 30-day backfill for late data<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt run</span> --select fct_payments --vars '{"lookback_days": 30}'<br>
<span class="comment"># ‚Üí Dimanche √† 2h, retraite 30 jours pour corriger les donn√©es tardives</span>
        </div>

        <h3>Comparaison des strat√©gies de lookback :</h3>
        <div class="code-block">
<b># Lookback court (1-3 jours) :</b><br>
<span class="hl">+ Performance optimale</span><br>
<span class="hl">+ Capture corrections imm√©diates</span><br>
<span class="hl">- Peut manquer des donn√©es tr√®s tardives</span><br>
<br>
<b># Lookback moyen (7-14 jours) :</b><br>
<span class="hl">+ Bon √©quilibre perf/couverture</span><br>
<span class="hl">+ Capture la plupart des late data</span><br>
<span class="hl">- Consomme plus de ressources</span><br>
<br>
<b># Lookback long (30+ jours) :</b><br>
<span class="hl">+ Capture toutes les donn√©es tardives</span><br>
<span class="hl">+ R√©silience maximale</span><br>
<span class="hl">- Performance impact√©e</span><br>
<span class="hl">- Co√ªt compute plus √©lev√©</span>
        </div>

        <p>La solution <strong>A</strong> offre le meilleur √©quilibre entre performance et capture des donn√©es tardives gr√¢ce √† sa fen√™tre de dates dynamique et configurable. Elle permet d'ajuster la strat√©gie de lookback selon les besoins sp√©cifiques du mod√®le et des patterns de donn√©es tardives.</p>
    </div>
</div>	  
	  
	  






<div class="q-card">
    <span class="q-head_green">QUESTION 41/65 : ENVIRONMENT VARIABLES DIAGNOSIS</span>
    <span class="q-txt">You define a Snowflake profile in <code>profiles.yml</code> referencing environment variables for the user, password, and account. You suspect your CI pipeline is failing because these vars aren't set. Which dbt command (or approach) helps confirm the environment variables are recognized and the profile is valid?</span>
    
    <div class="opt">A. <code>dbt compile --env-check</code></div>
    <div class="opt">B. <code>dbt debug</code></div>
    <div class="opt">C. <code>dbt run --check-vars</code></div>
    <div class="opt">D. <code>dbt docs serve --env</code></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>La commande <code>dbt debug</code> est l'outil de diagnostic standard de dbt pour v√©rifier la configuration du profil, tester la connexion √† la base de donn√©es et confirmer que toutes les variables d'environnement requises sont correctement d√©finies.</p>

        <h3>Ce que fait <code>dbt debug</code> :</h3>
        <div class="code-block">
<span class="keyword">dbt debug</span>
        </div>
        
        <div class="code-block">
<b># Sortie typique :</b><br>
Running with dbt=1.5.0<br>
dbt version: 1.5.0<br>
python version: 3.9.16<br>
python path: /usr/local/bin/python<br>
os info: Linux-5.10.0-1234-aws-x86_64-with-glibc2.31<br>
Using profiles.yml file at /home/user/.dbt/profiles.yml<br>
Using dbt_project.yml file at /home/user/my_project/dbt_project.yml<br>
<br>
Configuration:<br>
&nbsp;&nbsp;profiles.yml file [OK found and valid]<br>
&nbsp;&nbsp;dbt_project.yml file [OK found and valid]<br>
<br>
Required dependencies:<br>
&nbsp;&nbsp;- git [OK found]<br>
<br>
Connection:<br>
&nbsp;&nbsp;account: my_account<br>
&nbsp;&nbsp;user: dbt_user<br>
&nbsp;&nbsp;database: analytics<br>
&nbsp;&nbsp;schema: dbt_dev<br>
&nbsp;&nbsp;warehouse: compute_wh<br>
&nbsp;&nbsp;role: transformer<br>
&nbsp;&nbsp;Connection test: [OK connection ok]<br>
<br>
All checks passed!
        </div>

        <h3>Exemple de profil avec variables d'environnement :</h3>
        <div class="code-block">
<b># profiles.yml</b><br>
my_project:<br>
&nbsp;&nbsp;target: dev<br>
&nbsp;&nbsp;outputs:<br>
&nbsp;&nbsp;&nbsp;&nbsp;dev:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: snowflake<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;account: "{{ env_var('SNOWFLAKE_ACCOUNT') }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user: "{{ env_var('SNOWFLAKE_USER') }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;password: "{{ env_var('SNOWFLAKE_PASSWORD') }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;role: transformer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;database: analytics<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warehouse: compute_wh<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema: dbt_dev<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threads: 4
        </div>

        <h3>Si les variables ne sont pas d√©finies :</h3>
        <div class="code-block">
$ <span class="keyword">dbt debug</span><br>
<br>
Configuration:<br>
&nbsp;&nbsp;profiles.yml file [OK found and valid]<br>
&nbsp;&nbsp;dbt_project.yml file [OK found and valid]<br>
<br>
Required dependencies:<br>
&nbsp;&nbsp;- git [OK found]<br>
<br>
Connection:<br>
&nbsp;&nbsp;Encountered an error:<br>
&nbsp;&nbsp;<span class="hl">Env var required but not provided: 'SNOWFLAKE_ACCOUNT'</span>
        </div>

        <h3>Utilisation en CI/CD :</h3>
        <div class="code-block">
<b># .github/workflows/dbt_ci.yml</b><br>
jobs:<br>
&nbsp;&nbsp;dbt-run:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Checkout code<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uses: actions/checkout@v3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Debug dbt connection<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;env:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SNOWFLAKE_ACCOUNT: ${{ secrets.SNOWFLAKE_ACCOUNT }}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SNOWFLAKE_USER: ${{ secrets.SNOWFLAKE_USER }}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SNOWFLAKE_PASSWORD: ${{ secrets.SNOWFLAKE_PASSWORD }}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt debug</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Run dbt<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if: success()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt run</span>
        </div>

        <h3>Options de <code>dbt debug</code> :</h3>
        <div class="code-block">
<b># Debug avec un profil sp√©cifique :</b><br>
<span class="keyword">dbt debug</span> --profile my_profile<br>
<br>
<b># Debug avec une target sp√©cifique :</b><br>
<span class="keyword">dbt debug</span> --target prod<br>
<br>
<b># Debug avec config-dir personnalis√© :</b><br>
<span class="keyword">dbt debug</span> --profiles-dir /path/to/profiles<br>
<br>
<b># Debug plus d√©taill√© :</b><br>
<span class="keyword">dbt debug</span> --log-level debug
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>A ‚ùå :</b> <code>dbt compile --env-check</code>
                <ul>
                    <li><code>--env-check</code> n'est pas un flag valide pour <code>dbt compile</code></li>
                    <li><code>dbt compile</code> compile les mod√®les mais ne v√©rifie pas sp√©cifiquement la connexion</li>
                    <li>N'est pas l'outil de diagnostic appropri√©</li>
                </ul>
            </li>
            <li><b>C ‚ùå :</b> <code>dbt run --check-vars</code>
                <ul>
                    <li><code>--check-vars</code> n'existe pas comme flag pour <code>dbt run</code></li>
                    <li><code>dbt run</code> va simplement √©chouer si les variables ne sont pas d√©finies</li>
                    <li>Pas con√ßu pour le diagnostic</li>
                </ul>
            </li>
            <li><b>D ‚ùå :</b> <code>dbt docs serve --env</code>
                <ul>
                    <li><code>--env</code> n'est pas un flag valide</li>
                    <li><code>dbt docs serve</code> sert la documentation, ne teste pas la connexion</li>
                    <li>N'aide pas √† diagnostiquer les probl√®mes de variables d'environnement</li>
                </ul>
            </li>
        </ul>

        <h3>Diagnostic complet d'un probl√®me de profil :</h3>
        <div class="code-block">
<b># 1. V√©rifier que le fichier profiles.yml existe :</b><br>
<span class="keyword">ls</span> -la ~/.dbt/profiles.yml<br>
<br>
<b># 2. V√©rifier que les variables d'environnement sont d√©finies :</b><br>
<span class="keyword">echo</span> $SNOWFLAKE_ACCOUNT<br>
<span class="keyword">echo</span> $SNOWFLAKE_USER<br>
<span class="keyword">echo</span> $SNOWFLAKE_PASSWORD<br>
<br>
<b># 3. Exporter les variables si n√©cessaire :</b><br>
<span class="keyword">export</span> SNOWFLAKE_ACCOUNT="my_account"<br>
<span class="keyword">export</span> SNOWFLAKE_USER="dbt_user"<br>
<span class="keyword">export</span> SNOWFLAKE_PASSWORD="my_password"<br>
<br>
<b># 4. Lancer dbt debug :</b><br>
<span class="keyword">dbt debug</span><br>
<br>
<b># 5. Si succ√®s, lancer la compilation :</b><br>
<span class="keyword">dbt compile</span> --select my_model
        </div>

        <h3>Autres commandes utiles pour le diagnostic :</h3>
        <div class="code-block">
<b># Afficher la configuration active :</b><br>
<span class="keyword">dbt debug</span> --config-dir<br>
<br>
<b># Tester uniquement la connexion (sans compilation) :</b><br>
<span class="keyword">dbt debug</span> --connection<br>
<br>
<b># Verbose pour plus de d√©tails :</b><br>
<span class="keyword">dbt debug</span> --log-level debug<br>
<br>
<b># V√©rifier la configuration du projet :</b><br>
<span class="keyword">dbt debug</span> --config
        </div>

        <h3>Exemple de script de v√©rification CI :</h3>
        <div class="code-block">
<b>#!/bin/bash</b><br>
<span class="comment"># check_dbt_connection.sh</span><br>
<br>
<span class="keyword">set</span> -e<br>
<br>
<span class="keyword">echo</span> "Checking dbt configuration..."<br>
<br>
<b># V√©rifier les variables d'environnement requises</b><br>
required_vars=("SNOWFLAKE_ACCOUNT" "SNOWFLAKE_USER" "SNOWFLAKE_PASSWORD")<br>
<br>
<span class="keyword">for</span> var <span class="keyword">in</span> "${required_vars[@]}"; <span class="keyword">do</span><br>
&nbsp;&nbsp;<span class="keyword">if</span> [ -z "${!var}" ]; <span class="keyword">then</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">echo</span> "ERROR: Environment variable $var is not set"<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">exit</span> 1<br>
&nbsp;&nbsp;<span class="keyword">fi</span><br>
<span class="keyword">done</span><br>
<br>
<span class="keyword">echo</span> "All environment variables are set"<br>
<br>
<b># Tester la connexion avec dbt debug</b><br>
<span class="keyword">echo</span> "Testing dbt connection..."<br>
<span class="keyword">dbt debug</span><br>
<br>
<span class="keyword">echo</span> "dbt debug successful!"
        </div>

        <h3>Configuration avanc√©e pour diff√©rents environnements :</h3>
        <div class="code-block">
<b># profiles.yml avec multiples targets :</b><br>
my_project:<br>
&nbsp;&nbsp;target: dev<br>
&nbsp;&nbsp;outputs:<br>
&nbsp;&nbsp;&nbsp;&nbsp;dev:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: snowflake<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;account: "{{ env_var('SNOWFLAKE_DEV_ACCOUNT') }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user: "{{ env_var('SNOWFLAKE_USER') }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;password: "{{ env_var('SNOWFLAKE_DEV_PASSWORD') }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;role: transformer<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;database: analytics_dev<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warehouse: compute_wh<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema: dbt<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;prod:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: snowflake<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;account: "{{ env_var('SNOWFLAKE_PROD_ACCOUNT') }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user: "{{ env_var('SNOWFLAKE_PROD_USER') }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;password: "{{ env_var('SNOWFLAKE_PROD_PASSWORD') }}"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;role: transformer_prod<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;database: analytics<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warehouse: compute_wh<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;schema: dbt
        </div>

        <h3>D√©pannage √©tape par √©tape :</h3>
        <div class="code-block">
<b># √âtape 1: D√©finir les variables d'environnement :</b><br>
<span class="keyword">export</span> SNOWFLAKE_ACCOUNT=xyz12345.eu-central-1<br>
<span class="keyword">export</span> SNOWFLAKE_USER=dbt_service_account<br>
<span class="keyword">export</span> SNOWFLAKE_PASSWORD=my_secure_password<br>
<br>
<b># √âtape 2: Tester avec dbt debug :</b><br>
<span class="keyword">dbt debug</span> --target dev<br>
<br>
<b># √âtape 3: Si √©chec, v√©rifier le format :</b><br>
<span class="keyword">echo</span> "Account: $SNOWFLAKE_ACCOUNT"<br>
<span class="keyword">echo</span> "User: $SNOWFLAKE_USER"<br>
<span class="keyword">echo</span> "Password (length): ${#SNOWFLAKE_PASSWORD}"<br>
<br>
<b># √âtape 4: Tester avec curl pour Snowflake :</b><br>
<span class="keyword">curl</span> "https://$SNOWFLAKE_ACCOUNT.snowflakecomputing.com"
        </div>

        <h3>Utilisation avec Docker en CI :</h3>
        <div class="code-block">
<b># Dockerfile pour CI :</b><br>
FROM fishtownanalytics/dbt:1.5.0<br>
<br>
<b># Copier les profils avec env vars</b><br>
COPY profiles.yml /root/.dbt/<br>
<br>
<b># Script d'entr√©e</b><br>
COPY entrypoint.sh /entrypoint.sh<br>
RUN chmod +x /entrypoint.sh<br>
ENTRYPOINT ["/entrypoint.sh"]<br>
<br>
<b># entrypoint.sh :</b><br>
#!/bin/bash<br>
<span class="keyword">set</span> -e<br>
<br>
<span class="comment"># Tester la connexion avant d'ex√©cuter</span><br>
<span class="keyword">echo</span> "Testing dbt connection..."<br>
<span class="keyword">dbt debug</span><br>
<br>
<span class="comment"># Ex√©cuter la commande dbt</span><br>
<span class="keyword">dbt</span> "$@"
        </div>

        <p>La commande <strong><code>dbt debug</code></strong> est l'outil standard et le plus complet pour diagnostiquer les probl√®mes de profil et de variables d'environnement dans dbt. Elle valide √† la fois la configuration du fichier <code>profiles.yml</code> et la connexion √† la base de donn√©es, tout en fournissant des messages d'erreur clairs sur les variables manquantes.</p>
    </div>
</div>



















	  
		
		
		<div class="q-card">
            <span class="q-head_green">QUESTION 41/65 : DIAGNOSING PROFILES & ENV VARS</span>
            <span class="q-txt">You suspect your CI pipeline is failing because environment variables for Snowflake (user, password, account) aren't set. Which command helps confirm this?</span>
            
            <div class="opt">A - dbt compile --env-check</div>
            <div class="opt">B - dbt debug</div>
            <div class="opt">C - dbt run --check-vars</div>
            <div class="opt">D - dbt docs serve --env</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B - dbt debug.</strong>
                <p><b>Explication : dbt debug</b></p>
                <p>C'est l'outil de diagnostic standard. Il effectue plusieurs v√©rifications vitales :</p>
                <ul>
                    <li><b>Profil :</b> V√©rifie que <code>profiles.yml</code> est pr√©sent et syntaxiquement correct.</li>
                    <li><b>Variables d'environnement :</b> Tente de r√©soudre les <code>{{ env_var(...) }}</code>. Si une variable est manquante, il affiche explicitement l'erreur.</li>
                    <li><b>Connexion :</b> Teste la connectivit√© r√©elle avec le warehouse (Snowflake, BigQuery, etc.).</li>
                </ul>
                <div class="code-block">
                    <b>Sortie en cas d'erreur :</b><br>
                    Connection test: [ERROR]<br>
                    Env var required but not provided: 'SNOWFLAKE_ACCOUNT'
                </div>
            </div>
        </div>

        <div class="q-card">
            <span class="q-head_green">QUESTION 42/65 : ENV_VAR() LIMITATIONS</span>
            <span class="q-txt">Where can you use <b>env_var()</b> directly in dbt?</span>
            
            <div class="opt">A - Directly in a model's config() block.</div>
            <div class="opt">B - Directly in a schema.yml test definition.</div>
            <div class="opt">C - Directly in the dbt_project.yml and profiles.yml files.</div>
            <div class="opt">D - None of the above (Correct Approach: via dbt_project.yml vars).</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est D (None of the above).</strong>
                <p><b>Explication Correcte :</b></p>
                <p>Contrairement √† une id√©e re√ßue, <code>env_var()</code> ne peut <b>PAS</b> √™tre utilis√© directement dans un bloc <code>config()</code> d'un fichier <code>.sql</code>.</p>
                <p><b>Le workflow correct est :</b></p>
                <ol>
                    <li><b>dbt_project.yml :</b> On d√©finit une variable qui r√©cup√®re la variable d'environnement.<br>
                        <code>vars: staging_schema: "{{ env_var('PROD_SCHEMA') }}"</code></li>
                    <li><b>Mod√®le SQL :</b> On utilise <code>var()</code> dans le config.<br>
                        <code>{{ config(schema=var('staging_schema')) }}</code></li>
                </ol>
                
            </div>
        </div>




<div class="q-card">
    <span class="q-head_green">QUESTION 43/65 : SELECTIVE FULL REFRESH</span>
    <span class="q-txt">You have an incremental model <code>fct_sales</code> that normally processes new data. Once a quarter, you want to do a full refresh of just this one model. Which command accomplishes this?</span>
    
    <div class="opt">A. <code>dbt run --full-refresh</code> (runs full refresh for entire project)</div>
    <div class="opt">B. <code>dbt run --full-refresh -m fct_sales</code></div>
    <div class="opt">C. <code>dbt snapshot -m fct_sales</code></div>
    <div class="opt">D. <code>dbt run --state:full fct_sales</code></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Pour faire un full refresh d'un mod√®le sp√©cifique, on combine le flag <code>--full-refresh</code> avec un s√©lecteur de mod√®le <code>-m</code> (ou <code>--select</code>).</p>

        <h3>Commande correcte :</h3>
        <div class="code-block">
<span class="keyword">dbt run</span> --full-refresh -m fct_sales
        </div>
        
        <p>ou</p>
        
        <div class="code-block">
<span class="keyword">dbt run</span> --full-refresh --select fct_sales
        </div>

        <h3>Ce que fait cette commande :</h3>
        <ul>
            <li><code>dbt run</code> : Ex√©cute les mod√®les</li>
            <li><code>--full-refresh</code> : Force la reconstruction compl√®te (ignore la logique incr√©mentale)</li>
            <li><code>-m fct_sales</code> : S√©lectionne uniquement le mod√®le <code>fct_sales</code></li>
        </ul>

        <h3>R√©sultat :</h3>
        <ul>
            <li>Le mod√®le <code>fct_sales</code> est compl√®tement reconstruit (DROP + CREATE)</li>
            <li>La logique <code>is_incremental()</code> retourne <code>False</code></li>
            <li>Toutes les donn√©es sont recharg√©es</li>
            <li>Les autres mod√®les du projet ne sont pas affect√©s</li>
        </ul>

        <h3>Autres syntaxes valides :</h3>
        <div class="code-block">
<b># Avec --select :</b><br>
<span class="keyword">dbt run</span> --full-refresh --select fct_sales<br>
<br>
<b># Avec chemin complet :</b><br>
<span class="keyword">dbt run</span> --full-refresh -m marts.fct_sales<br>
<br>
<b># Full refresh + mod√®les en aval :</b><br>
<span class="keyword">dbt run</span> --full-refresh -m fct_sales+<br>
<br>
<b># Full refresh + mod√®les en amont :</b><br>
<span class="keyword">dbt run</span> --full-refresh -m +fct_sales<br>
<br>
<b># Full refresh sur plusieurs mod√®les :</b><br>
<span class="keyword">dbt run</span> --full-refresh -m fct_sales fct_orders
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>A ‚ùå :</b> <code>dbt run --full-refresh</code> (sans s√©lection)
                <ul>
                    <li>Fait un full refresh de TOUT le projet</li>
                    <li>Peut prendre des heures sur de gros projets</li>
                    <li>Pas ce qu'on veut (seulement un mod√®le)</li>
                </ul>
            </li>
            <li><b>C ‚ùå :</b> <code>dbt snapshot -m fct_sales</code>
                <ul>
                    <li><code>snapshot</code> est pour les snapshots, pas les mod√®les incr√©mentaux</li>
                    <li>Les snapshots capturent l'historique des donn√©es SCD Type 2</li>
                    <li>Commande compl√®tement diff√©rente</li>
                </ul>
            </li>
            <li><b>D ‚ùå :</b> <code>dbt run --state:full fct_sales</code>
                <ul>
                    <li><code>--state:full</code> n'est pas un flag valide</li>
                    <li>Syntaxe incorrecte</li>
                </ul>
            </li>
        </ul>

        <h3>Use case typique - Maintenance trimestrielle :</h3>
        <div class="code-block">
<b>#!/bin/bash</b><br>
<span class="comment"># quarterly_refresh.sh</span><br>
<br>
<span class="keyword">echo</span> "Starting quarterly full refresh of fct_sales..."<br>
<br>
<b># Full refresh du mod√®le principal</b><br>
<span class="keyword">dbt run</span> --full-refresh --select fct_sales<br>
<br>
<b># R√©g√©n√©rer les mod√®les d√©pendants en mode normal</b><br>
<span class="keyword">dbt run</span> --select fct_sales+<br>
<br>
<span class="keyword">echo</span> "Quarterly refresh completed!"
        </div>

        <h3>Avec logging :</h3>
        <div class="code-block">
<b># Avec logs d√©taill√©s :</b><br>
<span class="keyword">dbt run</span> --full-refresh -m fct_sales --log-level debug<br>
<br>
<b># Dry run pour voir ce qui serait ex√©cut√© :</b><br>
<span class="keyword">dbt run</span> --full-refresh -m fct_sales --dry-run<br>
<br>
<b># V√©rification avant ex√©cution :</b><br>
<span class="keyword">dbt ls</span> --resource-type model --select fct_sales<br>
<span class="comment">‚Üí Liste le mod√®le avant de l'ex√©cuter</span>
        </div>

        <h3>Configuration pour contr√¥ler le full refresh :</h3>
        <div class="code-block">
<span class="comment">-- models/marts/fct_sales.sql</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;materialized='incremental',<br>
&nbsp;&nbsp;&nbsp;&nbsp;unique_key='sale_id',<br>
&nbsp;&nbsp;&nbsp;&nbsp;full_refresh=false  <span class="comment">-- D√©sactive --full-refresh pour ce mod√®le</span><br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword">select</span> * <span class="keyword">from</span> {{ ref('stg_sales') }}<br>
<br>
{% if is_incremental() %}<br>
&nbsp;&nbsp;<span class="keyword">where</span> sale_date > (<span class="keyword">select</span> max(sale_date) <span class="keyword">from</span> {{ this }})<br>
{% endif %}
        </div>

        <div class="code-block">
<b># Override la config avec --vars :</b><br>
<span class="keyword">dbt run</span> --full-refresh -m fct_sales --vars '{force_full_refresh: true}'
        </div>

        <h3>Planification automatique avec CI/CD :</h3>
        <div class="code-block">
<b># .github/workflows/quarterly_refresh.yml</b><br>
name: Quarterly Full Refresh<br>
<br>
on:<br>
&nbsp;&nbsp;schedule:<br>
&nbsp;&nbsp;&nbsp;&nbsp;- cron: '0 2 1 */3 *'  <span class="comment"># 1er jour de chaque trimestre √† 2h</span><br>
&nbsp;&nbsp;workflow_dispatch:  <span class="comment"># Permet d√©clenchement manuel</span><br>
<br>
jobs:<br>
&nbsp;&nbsp;refresh:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- uses: actions/checkout@v3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Full refresh fct_sales<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: |<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">dbt run</span> --full-refresh --select fct_sales<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">dbt test</span> --select fct_sales
        </div>

        <h3>Monitoring du full refresh :</h3>
        <div class="code-block">
<span class="comment">-- models/utils/full_refresh_log.sql</span><br>
<span class="keyword">select</span><br>
&nbsp;&nbsp;'{{ run_started_at }}' <span class="keyword">as</span> refresh_timestamp,<br>
&nbsp;&nbsp;'fct_sales' <span class="keyword">as</span> model_name,<br>
&nbsp;&nbsp;'{{ invocation_id }}' <span class="keyword">as</span> invocation_id,<br>
&nbsp;&nbsp;count(*) <span class="keyword">as</span> row_count<br>
<span class="keyword">from</span> {{ ref('fct_sales') }}
        </div>

        <h3>Alternative : Full refresh conditionnel :</h3>
        <div class="code-block">
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;materialized='incremental',<br>
&nbsp;&nbsp;&nbsp;&nbsp;full_refresh="{{ var('quarterly_refresh', false) }}"<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword">select</span> * <span class="keyword">from</span> {{ ref('stg_sales') }}
        </div>

        <div class="code-block">
<b># Run normal :</b><br>
<span class="keyword">dbt run</span> -m fct_sales<br>
<br>
<b># Full refresh trimestriel :</b><br>
<span class="keyword">dbt run</span> -m fct_sales --vars '{quarterly_refresh: true}'
        </div>

        <h3>Diff√©rence entre les types d'ex√©cution :</h3>
        <div class="code-block">
<b># ‚ùå Normal run :</b><br>
<span class="keyword">dbt run</span> --select fct_sales<br>
<span class="comment">‚Üí Logique incr√©mentale activ√©e</span><br>
<span class="comment">‚Üí Seulement nouvelles donn√©es</span><br>
<br>
<b># ‚úÖ Full refresh s√©lectif :</b><br>
<span class="keyword">dbt run</span> --full-refresh --select fct_sales<br>
<span class="comment">‚Üí Logique incr√©mentale d√©sactiv√©e</span><br>
<span class="comment">‚Üí Toutes les donn√©es recharg√©es</span><br>
<br>
<b># ‚ùå Full refresh complet :</b><br>
<span class="keyword">dbt run</span> --full-refresh<br>
<span class="comment">‚Üí TOUS les mod√®les recharg√©s</span><br>
<span class="comment">‚Üí Tr√®s long et co√ªteux</span>
        </div>

        <h3>Impact sur les d√©pendances :</h3>
        <div class="code-block">
<b># Structure du DAG :</b><br>
stg_sales ‚Üí int_sales ‚Üí <span class="hl">fct_sales</span> ‚Üí dashboard_sales<br>
<br>
<b># 1. fct_sales seul :</b><br>
<span class="keyword">dbt run</span> --full-refresh --select fct_sales<br>
<span class="comment">‚Üí Seul fct_sales est reconstruit</span><br>
<span class="comment">‚Üí D√©pendances inchang√©es</span><br>
<br>
<b># 2. fct_sales + d√©pendants :</b><br>
<span class="keyword">dbt run</span> --full-refresh --select fct_sales+<br>
<span class="comment">‚Üí fct_sales reconstruit + dashboard_sales re-run</span><br>
<br>
<b># 3. D√©pendants seulement :</b><br>
<span class="keyword">dbt run</span> --select +fct_sales<br>
<span class="comment">‚Üí D√©pendants re-run (int_sales, fct_sales)</span>
        </div>

        <h3>Bonnes pratiques pour les full refresh trimestriels :</h3>
        <div class="code-block">
<b># 1. Planifier pendant les heures creuses :</b><br>
<span class="comment"># Ex√©cution √† 2h du matin</span><br>
<span class="keyword">dbt run</span> --full-refresh --select fct_sales --target prod<br>
<br>
<b># 2. Avertir l'√©quipe :</b><br>
<span class="comment">-- Pr√©-hook pour notification</span><br>
pre-hook:<br>
&nbsp;&nbsp;- "{{ notify_team('Starting quarterly full refresh of fct_sales') }}"<br>
<br>
<b># 3. Backup avant refresh :</b><br>
pre-hook:<br>
&nbsp;&nbsp;- "CREATE TABLE fct_sales_backup_{{ run_started_at.strftime('%Y%m%d') }} AS SELECT * FROM fct_sales"<br>
<br>
<b># 4. Validation apr√®s refresh :</b><br>
post-hook:<br>
&nbsp;&nbsp;- "{{ validate_row_count('fct_sales') }}"
        </div>

        <p>La commande <strong><code>dbt run --full-refresh -m fct_sales</code></strong> est la fa√ßon standard et pr√©cise de faire un full refresh d'un seul mod√®le incr√©mental sans affecter le reste du projet, parfaitement adapt√©e aux maintenances trimestrielles planifi√©es.</p>
    </div>
</div>
		
		 




<div class="q-card">
    <span class="q-head_green">QUESTION 44/65 :: RESOURCE CONTENTION RESOLUTION</span>
    <span class="q-txt">Your dbt project has 200 models. You set <code>threads: 8</code> in <code>profiles.yml</code>. You notice your warehouse struggles with resource contention, occasionally failing runs. Which approach might help mitigate concurrency issues?</span>
    
    <div class="opt">A. Increase threads to 32 to build all models faster.</div>
    <div class="opt">B. Decrease threads or selectively run fewer models in parallel.</div>
    <div class="opt">C. Convert all models to ephemeral, so there are no physical writes.</div>
    <div class="opt">D. Set <code>on_schema_change='ignore'</code> for all models.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Quand le data warehouse subit une contention de ressources (trop de requ√™tes simultan√©es), la solution est de r√©duire le parall√©lisme, pas de l'augmenter.</p>

        <h3>Pourquoi B est correct :</h3>
        <p>Le probl√®me d√©crit est la <b>resource contention</b> (contention de ressources) :</p>
        <ul>
            <li>Trop de threads ‚Üí Trop de requ√™tes simultan√©es</li>
            <li>Warehouse surcharg√© ‚Üí √âchecs de runs</li>
            <li>Solution : Moins de parall√©lisme</li>
        </ul>

        <h3>Options pour r√©duire la contention :</h3>
        
        <div class="code-block">
<b># 1. R√©duire le nombre de threads :</b><br>
<span class="comment"># profiles.yml</span><br>
my_project:<br>
&nbsp;&nbsp;target: prod<br>
&nbsp;&nbsp;outputs:<br>
&nbsp;&nbsp;&nbsp;&nbsp;prod:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: snowflake<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threads: 4  <span class="comment"># R√©duit de 8 √† 4</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># ...autres configs</span>
        </div>

        <div class="code-block">
<b># 2. Ex√©cution s√©lective par lots :</b><br>
<span class="comment"># Au lieu de tout ex√©cuter en une fois</span><br>
<span class="keyword">dbt run</span>  <span class="comment"># 200 mod√®les avec 8 threads = 8 mod√®les simultan√©s</span><br>
<br>
<span class="comment"># Ex√©cuter par cat√©gories</span><br>
<span class="keyword">dbt run</span> --select staging  <span class="comment"># Uniquement staging</span><br>
<span class="keyword">dbt run</span> --select marts    <span class="comment"># Puis marts</span><br>
<span class="keyword">dbt run</span> --select reporting  <span class="comment"># Enfin reporting</span>
        </div>

        <div class="code-block">
<b># 3. Ex√©cution s√©quentielle des mod√®les critiques :</b><br>
<span class="keyword">dbt run</span> --select fct_large_table --threads 1<br>
<span class="keyword">dbt run</span> --select +fct_large_table+ --threads 4
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>A ‚ùå :</b> Augmenter √† 32 threads
                <ul>
                    <li>AGGRAVE le probl√®me</li>
                    <li>Plus de threads = Plus de requ√™tes simultan√©es</li>
                    <li>Plus de contention, plus d'√©checs</li>
                    <li>Exactement l'inverse de ce qu'il faut faire</li>
                </ul>
            </li>
            <li><b>C ‚ùå :</b> Tout convertir en ephemeral
                <ul>
                    <li>Les mod√®les ephemeral sont des CTEs, pas des tables physiques</li>
                    <li>Ne r√©sout PAS la contention (les requ√™tes s'ex√©cutent quand m√™me)</li>
                    <li>Perd les avantages de la mat√©rialisation</li>
                    <li>Peut m√™me ralentir (CTEs r√©ex√©cut√©es √† chaque fois)</li>
                    <li>Pas une solution viable pour 200 mod√®les</li>
                </ul>
            </li>
            <li><b>D ‚ùå :</b> <code>on_schema_change='ignore'</code>
                <ul>
                    <li>N'a RIEN √† voir avec la contention de ressources</li>
                    <li>C'est pour g√©rer les changements de sch√©ma dans les mod√®les incr√©mentaux</li>
                    <li>Ne change pas le parall√©lisme ou l'utilisation des ressources</li>
                </ul>
            </li>
        </ul>

        <h3>Strat√©gies avanc√©es de gestion de threads :</h3>
        
        <div class="code-block">
<b># 1. Threads diff√©rents par environnement :</b><br>
<span class="comment"># profiles.yml</span><br>
my_project:<br>
&nbsp;&nbsp;target: dev<br>
&nbsp;&nbsp;outputs:<br>
&nbsp;&nbsp;&nbsp;&nbsp;dev:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threads: 8    <span class="comment"># Plus en dev (moins d'utilisateurs)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;prod:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threads: 4    <span class="comment"># Moins en prod (warehouse partag√©)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;ci:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threads: 2    <span class="comment"># Tr√®s peu en CI (petites ressources)</span>
        </div>

        <div class="code-block">
<b># 2. Ex√©cution par vagues (waves) :</b><br>
<b>#!/bin/bash</b><br>
<span class="comment"># run_in_waves.sh</span><br>
<br>
<span class="comment"># Vague 1: Staging (l√©ger, rapide)</span><br>
<span class="keyword">dbt run</span> --select staging --threads 8<br>
<br>
<span class="comment"># Vague 2: Intermediate (moyen)</span><br>
<span class="keyword">dbt run</span> --select intermediate --threads 4<br>
<br>
<span class="comment"># Vague 3: Marts (lourd, un par un)</span><br>
<span class="keyword">dbt run</span> --select marts --threads 2
        </div>

        <div class="code-block">
<b># 3. Limiter les mod√®les simultan√©s :</b><br>
<span class="comment"># dbt_project.yml</span><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large_models:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+threads: 1  <span class="comment"># Force l'ex√©cution s√©quentielle</span>
        </div>

        <h3>Monitoring et ajustement :</h3>
        <div class="code-block">
<span class="comment">-- Surveiller l'utilisation du warehouse (Snowflake)</span><br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;query_text,<br>
&nbsp;&nbsp;execution_status,<br>
&nbsp;&nbsp;queued_overload_time,<br>
&nbsp;&nbsp;execution_time<br>
<span class="keyword">FROM</span> snowflake.account_usage.query_history<br>
<span class="keyword">WHERE</span> user_name = 'DBT_USER'<br>
&nbsp;&nbsp;<span class="keyword">AND</span> start_time > DATEADD(hour, -1, CURRENT_TIMESTAMP())<br>
<span class="keyword">ORDER BY</span> start_time <span class="keyword">DESC</span>;
        </div>

        <h3>Sympt√¥mes de trop de threads :</h3>
        <div class="code-block">
<b># Indicateurs de contention :</b><br>
‚úÖ Requ√™tes en file d'attente (queued)<br>
‚úÖ Timeouts de connexion<br>
‚úÖ Erreurs de ressources insuffisantes<br>
‚úÖ Temps d'ex√©cution plus long (paradoxalement)<br>
‚úÖ Warehouse scaling non optimal
        </div>

        <h3>Calcul optimal des threads :</h3>
        <div class="code-block">
<b># R√®gle g√©n√©rale :</b><br>
Threads recommand√©s = Taille du warehouse / Charge projet<br>
<br>
<b># Exemples (Snowflake) :</b><br>
- XS warehouse (1 cluster) ‚Üí 2-4 threads<br>
- S warehouse (2 clusters) ‚Üí 4-8 threads<br>
- M warehouse (4 clusters) ‚Üí 8-16 threads<br>
- L warehouse (8 clusters) ‚Üí 16-32 threads<br>
<br>
<b># Facteurs √† consid√©rer :</b><br>
‚Ä¢ Taille des mod√®les (lignes/colonnes)<br>
‚Ä¢ Complexit√© des transformations<br>
‚Ä¢ Autres charges sur le warehouse<br>
‚Ä¢ CPU/m√©moire disponibles
        </div>

        <h3>Configuration adaptative :</h3>
        <div class="code-block">
<b># profiles.yml avec variables d'environnement :</b><br>
my_project:<br>
&nbsp;&nbsp;target: "{{ env_var('DBT_TARGET', 'dev') }}"<br>
&nbsp;&nbsp;outputs:<br>
&nbsp;&nbsp;&nbsp;&nbsp;dev:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threads: "{{ env_var('DBT_THREADS', 8) | int }}"<br>
<br>
<b># Ajuster selon la charge :</b><br>
<span class="keyword">export</span> DBT_THREADS=4<br>
<span class="keyword">dbt run</span><br>
<br>
<b># Pour un run critique avec peu de contention :</b><br>
<span class="keyword">export</span> DBT_THREADS=2<br>
<span class="keyword">dbt run</span> --select critical_models
        </div>

        <h3>Utiliser les selectors pour contr√¥ler l'ex√©cution :</h3>
        <div class="code-block">
<b># selectors.yml :</b><br>
selectors:<br>
&nbsp;&nbsp;- name: light_load<br>
&nbsp;&nbsp;&nbsp;&nbsp;definition:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- method: tag<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: small<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- method: path<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: staging/*<br>
<br>
&nbsp;&nbsp;- name: heavy_load<br>
&nbsp;&nbsp;&nbsp;&nbsp;definition:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method: tag<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: large<br>
<br>
<b># Ex√©cution contr√¥l√©e :</b><br>
<span class="keyword">dbt run</span> --selector light_load --threads 8<br>
<span class="keyword">dbt run</span> --selector heavy_load --threads 2
        </div>

        <h3>Approche par phases pour 200 mod√®les :</h3>
        <div class="code-block">
<b># Phase 1: Staging (40 mod√®les) :</b><br>
<span class="keyword">dbt run</span> --select tag:staging --threads 8<br>
<span class="comment">‚Üí 5 vagues de 8 mod√®les</span><br>
<br>
<b># Phase 2: Intermediate (60 mod√®les) :</b><br>
<span class="keyword">dbt run</span> --select tag:intermediate --threads 6<br>
<span class="comment">‚Üí 10 vagues de 6 mod√®les</span><br>
<br>
<b># Phase 3: Marts (100 mod√®les) :</b><br>
<span class="keyword">dbt run</span> --select tag:marts --threads 4<br>
<span class="comment">‚Üí 25 vagues de 4 mod√®les</span>
        </div>

        <h3>Optimisation pour diff√©rents warehouses :</h3>
        <div class="code-block">
<b># BigQuery (slots) :</b><br>
<span class="comment"># profiles.yml</span><br>
bigquery:<br>
&nbsp;&nbsp;type: bigquery<br>
&nbsp;&nbsp;method: service-account<br>
&nbsp;&nbsp;threads: 10  <span class="comment"># Tester entre 5-20 selon les slots</span><br>
&nbsp;&nbsp;priority: interactive  <span class="comment"># ou batch pour moins de contention</span><br>
<br>
<b># Redshift (queues) :</b><br>
redshift:<br>
&nbsp;&nbsp;type: redshift<br>
&nbsp;&nbsp;threads: 4  <span class="comment"># G√©n√©ralement plus bas</span><br>
&nbsp;&nbsp;wlm_query_slot_count: 1<br>
<br>
<b># Databricks (clusters) :</b><br>
databricks:<br>
&nbsp;&nbsp;type: databricks<br>
&nbsp;&nbsp;threads: 8  <span class="comment"># Selon le nombre d'executors</span>
        </div>

        <h3>Diagnostic et ajustement en temps r√©el :</h3>
        <div class="code-block">
<b># Script de monitoring :</b><br>
<b>#!/bin/bash</b><br>
<span class="comment"># monitor_and_adjust.sh</span><br>
<br>
<span class="comment"># 1. Mesurer le temps moyen d'ex√©cution</span><br>
START_TIME=$(date +%s)<br>
<span class="keyword">dbt run</span> --select tag:test --threads 4<br>
END_TIME=$(date +%s)<br>
<br>
<span class="comment"># 2. Calculer et ajuster</span><br>
DURATION=$((END_TIME - START_TIME))<br>
<br>
<span class="keyword">if</span> [ $DURATION -gt 300 ]; <span class="keyword">then</span>  <span class="comment"># > 5 minutes</span><br>
&nbsp;&nbsp;<span class="keyword">echo</span> "Trop long, r√©duire les threads..."<br>
&nbsp;&nbsp;<span class="keyword">dbt run</span> --threads 2<br>
<span class="keyword">else</span><br>
&nbsp;&nbsp;<span class="keyword">echo</span> "Performances OK, continuer avec 4 threads"<br>
&nbsp;&nbsp;<span class="keyword">dbt run</span> --threads 4<br>
<span class="keyword">fi</span>
        </div>

        <p>La cl√© est de r√©duire le parall√©lisme quand le warehouse montre des signes de contention. La r√©ponse <strong>B</strong> propose soit de diminuer le nombre de threads, soit d'ex√©cuter moins de mod√®les en parall√®le, ce qui sont les deux approches correctes pour r√©soudre les probl√®mes de contention de ressources.</p>
    </div>
</div>



		
		
		 <div class="q-card">
    <span class="q-head_green">QUESTION 45/65 :: SELECTIVE SEED LOADING</span>
    <span class="q-txt">You have multiple seeds, but only want to load <code>product_codes.csv</code> while ignoring others. Which command accomplishes this?</span>
    
    <div class="opt">A. <code>dbt run --select seeds.product_codes</code></div>
    <div class="opt">B. <code>dbt seed --select product_codes</code></div>
    <div class="opt">C. <code>dbt build --full-refresh product_codes</code></div>
    <div class="opt">D. <code>dbt run-operation seed --seed product_codes</code></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Pour charger un seed sp√©cifique, on utilise la commande <code>dbt seed</code> avec le s√©lecteur <code>--select</code> (ou <code>-s</code>).</p>

        <h3>Commande correcte :</h3>
        <div class="code-block">
<span class="keyword">dbt seed</span> --select product_codes
        </div>
        
        <div class="code-block">
<span class="keyword">dbt seed</span> -s product_codes
        </div>

        <h3>Ce que fait cette commande :</h3>
        <ul>
            <li><code>dbt seed</code> : Commande pour charger les seeds (fichiers CSV)</li>
            <li><code>--select product_codes</code> : S√©lectionne uniquement le seed nomm√© <code>product_codes</code></li>
            <li>Les autres seeds sont ignor√©s</li>
        </ul>

        <h3>Structure de fichiers :</h3>
        <div class="code-block">
my_project/<br>
‚îú‚îÄ‚îÄ seeds/<br>
‚îÇ   ‚îú‚îÄ‚îÄ product_codes.csv      <span class="comment">‚Üê Charg√©</span><br>
‚îÇ   ‚îú‚îÄ‚îÄ country_codes.csv      <span class="comment">‚Üê Ignor√©</span><br>
‚îÇ   ‚îî‚îÄ‚îÄ currency_rates.csv     <span class="comment">‚Üê Ignor√©</span>
        </div>

        <h3>Autres syntaxes de s√©lection pour seeds :</h3>
        <div class="code-block">
<b># Par nom exact :</b><br>
<span class="keyword">dbt seed</span> --select product_codes<br>
<br>
<b># Par pattern :</b><br>
<span class="keyword">dbt seed</span> --select "*_codes"<br>
<br>
<b># Multiple seeds :</b><br>
<span class="keyword">dbt seed</span> --select product_codes country_codes<br>
<br>
<b># Par dossier :</b><br>
<span class="keyword">dbt seed</span> --select seeds/reference/*<br>
<br>
<b># Exclure certains seeds :</b><br>
<span class="keyword">dbt seed</span> --exclude country_codes<br>
<br>
<b># Tous les seeds d'un type :</b><br>
<span class="keyword">dbt seed</span> --select resource_type:seed
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>A ‚ùå :</b> <code>dbt run --select seeds.product_codes</code>
                <ul>
                    <li><code>dbt run</code> ex√©cute des mod√®les, pas des seeds</li>
                    <li>Seeds ne font pas partie des ressources ex√©cut√©es par <code>dbt run</code></li>
                    <li>Syntaxe invalide</li>
                </ul>
            </li>
            <li><b>C ‚ùå :</b> <code>dbt build --full-refresh product_codes</code>
                <ul>
                    <li><code>dbt build</code> peut charger des seeds, mais la syntaxe est incorrecte</li>
                    <li><code>--full-refresh</code> n'est pas combin√© correctement avec la s√©lection</li>
                    <li>La bonne syntaxe serait : <code>dbt build --select product_codes</code></li>
                </ul>
            </li>
            <li><b>D ‚ùå :</b> <code>dbt run-operation seed --seed product_codes</code>
                <ul>
                    <li><code>dbt run-operation</code> est pour ex√©cuter des macros manuellement</li>
                    <li><code>seed</code> n'est pas une macro, c'est une commande</li>
                    <li><code>--seed</code> n'est pas un flag valide</li>
                    <li>Syntaxe compl√®tement incorrecte</li>
                </ul>
            </li>
        </ul>

        <h3>Cas d'usage complets :</h3>
        <div class="code-block">
<b># 1. Chargement initial d'un seed :</b><br>
<span class="keyword">dbt seed</span> --select product_codes --full-refresh<br>
<br>
<b># 2. Mise √† jour d'un seed existant :</b><br>
<span class="keyword">dbt seed</span> --select product_codes<br>
<br>
<b># 3. Avec tests apr√®s chargement :</b><br>
<span class="keyword">dbt seed</span> --select product_codes<br>
<span class="keyword">dbt test</span> --select product_codes<br>
<br>
<b># 4. Utiliser dbt build pour tout :</b><br>
<span class="keyword">dbt build</span> --select product_codes
        </div>

        <h3>Configuration des seeds :</h3>
        <div class="code-block">
<b># dbt_project.yml</b><br>
seeds:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;product_codes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+enabled: true<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+schema: reference_data<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+quote_columns: false<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+column_types:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product_id: varchar(10)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product_name: varchar(100)
        </div>

        <h3>Seeds avec tags :</h3>
        <div class="code-block">
<b># dbt_project.yml</b><br>
seeds:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;product_codes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+tags: ['reference', 'daily_refresh']<br>
&nbsp;&nbsp;&nbsp;&nbsp;country_codes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+tags: ['reference', 'static']<br>
<br>
<b># Charger par tag :</b><br>
<span class="keyword">dbt seed</span> --select tag:daily_refresh<br>
<br>
<b># Exclure par tag :</b><br>
<span class="keyword">dbt seed</span> --exclude tag:static
        </div>

        <h3>Workflow CI/CD pour seeds :</h3>
        <div class="code-block">
<b># .github/workflows/seeds.yml</b><br>
name: Load Seeds<br>
<br>
on:<br>
&nbsp;&nbsp;push:<br>
&nbsp;&nbsp;&nbsp;&nbsp;paths:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 'seeds/product_codes.csv'<br>
<br>
jobs:<br>
&nbsp;&nbsp;load-seed:<br>
&nbsp;&nbsp;&nbsp;&nbsp;runs-on: ubuntu-latest<br>
&nbsp;&nbsp;&nbsp;&nbsp;steps:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- uses: actions/checkout@v3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Load product_codes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt seed</span> --select product_codes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: Test seed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;run: <span class="keyword">dbt test</span> --select product_codes
        </div>

        <h3>V√©rification avant chargement :</h3>
        <div class="code-block">
<b># Lister les seeds disponibles :</b><br>
<span class="keyword">dbt ls</span> --resource-type seed<br>
<br>
<b># Voir quel seed sera charg√© :</b><br>
<span class="keyword">dbt seed</span> --select product_codes --dry-run<br>
<br>
<b># Compiler pour voir la config :</b><br>
<span class="keyword">dbt compile</span> --select product_codes
        </div>

        <h3>Tests sur seeds :</h3>
        <div class="code-block">
<b># seeds/schema.yml</b><br>
version: 2<br>
<br>
seeds:<br>
&nbsp;&nbsp;- name: product_codes<br>
&nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: product_id<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- unique<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: product_name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null
        </div>

        <h3>Performance pour gros seeds :</h3>
        <div class="code-block">
<b># dbt_project.yml</b><br>
seeds:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;product_codes:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+materialized: table<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+post-hook:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- "create index if not exists idx_product_id on {{ this }} (product_id)"
        </div>

        <p>La commande <code>dbt seed --select product_codes</code> est la m√©thode standard et directe pour charger un seed sp√©cifique tout en ignorant les autres.</p>
    </div>
</div>
		
		
		
		
		<div class="q-card">
            <span class="q-head_green">QUESTION 46/65 :: CONFIRMING MATERIALIZATIONS</span>
            <span class="q-txt">You want to confirm <b>stg_orders</b> is a view, <b>fct_orders</b> is a table, and <b>agg_monthly_orders</b> is incremental. Which CLI approach can quickly confirm this?</span>
            
            <div class="opt">A - dbt debug --models stg_orders fct_orders agg_monthly_orders</div>
            <div class="opt">B - dbt run -m stg_orders fct_orders agg_monthly_orders and inspect the manifest.json or run SQL in target/</div>
            <div class="opt">C - dbt test --select config:materialized='table'</div>
            <div class="opt">D - dbt build --materialization-check</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ La bonne r√©ponse est B.</strong>
                <hr>
                <h4>üí° Pourquoi la r√©ponse B est la plus fiable ?</h4>
                <p>Pour v√©rifier comment dbt a r√©ellement interpr√©t√© vos configurations (qui peuvent provenir du <code>dbt_project.yml</code> ou des blocs <code>config()</code>), il faut inspecter les artefacts g√©n√©r√©s apr√®s compilation ou ex√©cution.</p>

                

                <h4>üîç M√©thodes d'inspection :</h4>
                <ul>
                    <li><b>Manifest.json :</b> Situ√© dans <code>target/</code>, ce fichier JSON contient la configuration finale "r√©solue" de chaque mod√®le.
                        <div class="code-block">cat target/manifest.json | jq '.nodes[] | select(.name == "stg_orders") | .config.materialized'</div>
                    </li>
                    <li><b>SQL compil√© :</b> Regardez dans <code>target/run/</code>.
                        <ul>
                            <li><code>CREATE VIEW...</code> ‚Üí View</li>
                            <li><code>CREATE TABLE...</code> ‚Üí Table</li>
                            <li><code>MERGE...</code> ou <code>INSERT INTO...</code> ‚Üí Incremental</li>
                        </ul>
                    </li>
                    <li><b>Commande alternative rapide :</b>
                        <div class="code-block">dbt ls -m stg_orders+ --output json | jq '.config.materialized'</div>
                    </li>
                </ul>

                <h4>‚ö†Ô∏è Pourquoi les autres options sont incorrectes :</h4>
                <ul>
                    <li><b>A :</b> <code>dbt debug</code> ne supporte pas le flag <code>--models</code> et teste uniquement la connexion/les fichiers de config de base.</li>
                    <li><b>C :</b> <code>dbt test</code> ex√©cute des tests de donn√©es (not null, unique), pas des v√©rifications de configuration.</li>
                    <li><b>D :</b> <code>--materialization-check</code> est un flag imaginaire qui n'existe pas dans le CLI dbt.</li>
                </ul>

                <p><b>Conseil :</b> En cas de doute, la commande <code>dbt ls --output json</code> filtr√©e avec <code>jq</code> est votre meilleur ami pour auditer un projet complexe.</p>
            </div>
        </div>
		
		
		
		
		<div class="q-card">
    <span class="q-head_red">QUESTION 47/65 :: DATABASE CONFIGURATION OVERRIDE</span>
    <span class="q-txt">Your default dbt profile writes to <code>DEV_DB</code>. However, you want just one model, <code>dim_finance</code>, to be in <code>FINANCE_DB</code>. How do you configure this?</span>
    
    <div class="opt">A. In dim_finance.sql (top of the file):<br>
<pre>{{ config(database='FINANCE_DB') }}
SELECT ...</pre></div>
    
    <div class="opt">B. In dbt_project.yml under that model's config block:<br>
<pre>models:
  my_project:
    dim_finance:
      +database: FINANCE_DB</pre></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponses correctes : A et B (LES DEUX)</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Pour surcharger la base de donn√©es d'un mod√®le sp√©cifique, on peut utiliser soit la config dans le fichier .sql du mod√®le, soit la configuration dans dbt_project.yml. Les deux approches sont valides.</p>

        <h3>Option A : Configuration dans le fichier mod√®le (.sql)</h3>
        <div class="code-block">
<span class="comment">-- models/marts/dim_finance.sql</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;database='FINANCE_DB'<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword">select</span><br>
&nbsp;&nbsp;finance_id,<br>
&nbsp;&nbsp;account_name,<br>
&nbsp;&nbsp;balance<br>
<span class="keyword">from</span> {{ ref('stg_finance') }}
        </div>

        <p><b>Avantages :</b></p>
        <ul>
            <li>Configuration au plus pr√®s du mod√®le</li>
            <li>Facile √† trouver et modifier</li>
            <li>Visible pour qui travaille sur ce fichier sp√©cifique</li>
        </ul>

        <h3>Option B : Configuration dans dbt_project.yml</h3>
        <div class="code-block">
<b># dbt_project.yml</b><br>
name: my_project<br>
<br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim_finance:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+database: FINANCE_DB
        </div>

        <p><b>Avantages :</b></p>
        <ul>
            <li>Configuration centralis√©e</li>
            <li>Facile de voir toutes les surcharges de database</li>
            <li>Utile pour g√©rer plusieurs mod√®les similaires</li>
        </ul>

        <h3>Ordre de priorit√© des configurations :</h3>
        <div class="code-block">
<b># 1. Config dans le fichier .sql (PLUS HAUTE PRIORIT√â)</b><br>
<b># 2. Config dans dbt_project.yml pour ce mod√®le sp√©cifique</b><br>
<b># 3. Config dans dbt_project.yml pour le dossier parent</b><br>
<b># 4. Config dans profiles.yml (DEFAULT)</b>
        </div>

        <h3>Exemple complet avec plusieurs niveaux :</h3>
        <div class="code-block">
<b># dbt_project.yml</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+database: DEV_DB  <span class="comment"># Default pour tout le projet</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+database: ANALYTICS_DB  <span class="comment"># Pour tous les marts</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim_finance:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+database: FINANCE_DB  <span class="comment"># Seulement pour dim_finance</span>
        </div>

        <div class="code-block">
<span class="comment">-- models/marts/dim_finance.sql</span><br>
<span class="comment">-- Si on ajoute ici, √ßa surcharge TOUT</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;database='COMPLIANCE_DB'  <span class="comment"># Priorit√© maximale!</span><br>
&nbsp;&nbsp;)<br>
}}
        </div>

        <h3>R√©sultat final :</h3>
        <p><code>dim_finance</code> sera dans <code>COMPLIANCE_DB</code> (config du fichier .sql gagne)</p>

        <h3>Configuration par environnement :</h3>
        <div class="code-block">
<b># Option A avec logique :</b><br>
<span class="comment">-- models/marts/dim_finance.sql</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;database='FINANCE_DB' if target.name == 'prod' else 'DEV_DB'<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword">select</span> * <span class="keyword">from</span> {{ ref('stg_finance') }}
        </div>

        <div class="code-block">
<b># Option B avec logique :</b><br>
<span class="comment"># dbt_project.yml</span><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;dim_finance:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+database: "{{ 'FINANCE_DB' if target.name == 'prod' else 'DEV_DB' }}"
        </div>

        <h3>Cas d'usage r√©els :</h3>
        <div class="code-block">
<b># 1. Donn√©es sensibles isol√©es :</b><br>
<span class="comment"># Mod√®les financiers dans une DB s√©par√©e avec permissions strictes</span><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finance:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+database: FINANCE_DB<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+schema: restricted
        </div>

        <div class="code-block">
<b># 2. Donn√©es par d√©partement :</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim_finance:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+database: FINANCE_DB<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim_sales:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+database: SALES_DB<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dim_hr:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+database: HR_DB
        </div>

        <div class="code-block">
<b># 3. Multi-tenant :</b><br>
<span class="comment">-- Avec variable</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;database=var('client_database', 'DEV_DB')<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword"># Commande</span><br>
<span class="keyword">dbt run</span> -m dim_finance --vars '{"client_database": "CLIENT_A_DB"}'
        </div>

        <h3>Combinaison database + schema :</h3>
        <div class="code-block">
<span class="comment">-- models/marts/dim_finance.sql</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;database='FINANCE_DB',<br>
&nbsp;&nbsp;&nbsp;&nbsp;schema='reporting',<br>
&nbsp;&nbsp;&nbsp;&nbsp;alias='financial_dimensions'<br>
&nbsp;&nbsp;)<br>
}}
        </div>

        <h3>Configuration compl√®te avec tous les param√®tres :</h3>
        <div class="code-block">
<b># dbt_project.yml</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;dim_finance:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+database: FINANCE_DB<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+schema: marts<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+alias: dim_finance<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+materialized: table<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+tags: ['finance', 'sensitive']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+meta:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;owner: 'finance_team'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contains_pii: true
        </div>

        <h3>V√©rification de la configuration :</h3>
        <div class="code-block">
<b># Voir o√π le mod√®le sera cr√©√© :</b><br>
<span class="keyword">dbt compile</span> -m dim_finance<br>
<br>
<b># Inspecter le manifest :</b><br>
<span class="keyword">cat</span> target/manifest.json | jq '.nodes[] | select(.name=="dim_finance") | {database: .database, schema: .schema}'
        </div>

        <h3>Best practice :</h3>
        <div class="code-block">
<b># Utilisez dbt_project.yml pour :</b><br>
- Configurations de dossiers entiers<br>
- Patterns coh√©rents<br>
- Vue d'ensemble centralis√©e<br>
<br>
<b># Utilisez config() dans .sql pour :</b><br>
- Exceptions sp√©cifiques<br>
- Logique complexe (conditions Jinja)<br>
- Configuration tr√®s sp√©cifique √† un mod√®le
        </div>

        <p>Les deux options <strong>A</strong> et <strong>B</strong> sont correctes et peuvent m√™me √™tre combin√©es (le fichier .sql ayant la priorit√© sur dbt_project.yml).</p>
    </div>
</div>
		
		
		
		
		
		
		<div class="q-card">
    <span class="q-head_green">QUESTION 48/65 :: TEST COST OPTIMIZATION</span>
    <span class="q-txt">Your team runs all tests (schema + data tests) on a 500M-row table daily. This is becoming costly in your Snowflake warehouse. You still want reliable data checks but also control costs. Which approach is recommended?</span>
    
    <div class="opt">A. Move the entire table to ephemeral, so tests don't run physically.</div>
    <div class="opt">B. Use a sampling strategy or partial tests, e.g., only test the last 7 days, or create a smaller test table.</div>
    <div class="opt">C. Convert tests to snapshot logic.</div>
    <div class="opt">D. Hard-code each test to check just one row.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Pour optimiser les co√ªts de tests sur de tr√®s grandes tables, l'approche recommand√©e est d'utiliser des strat√©gies d'√©chantillonnage ou des tests partiels qui v√©rifient la qualit√© des donn√©es sans scanner toute la table.</p>

        <h3>Strat√©gies recommand√©es :</h3>
        
        <div class="code-block">
<b># 1. Tests sur une fen√™tre temporelle r√©cente :</b><br>
<span class="comment">-- tests/test_orders_no_negative_amounts_recent.sql</span><br>
<span class="keyword">select</span> *<br>
<span class="keyword">from</span> {{ ref('fct_orders') }}<br>
<span class="keyword">where</span> order_amount < 0<br>
&nbsp;&nbsp;<span class="keyword">and</span> order_date >= DATEADD(day, -7, CURRENT_DATE())  <span class="comment">-- Seulement 7 derniers jours</span>
        </div>

        <p><b>B√©n√©fices :</b></p>
        <ul>
            <li>R√©duit drastiquement le volume scann√©</li>
            <li>D√©tecte rapidement les nouveaux probl√®mes</li>
            <li>Les donn√©es historiques sont stables</li>
        </ul>

        <div class="code-block">
<b># 2. Tests avec √©chantillonnage :</b><br>
<span class="comment">-- tests/test_orders_sample_quality.sql</span><br>
<span class="keyword">select</span> *<br>
<span class="keyword">from</span> {{ ref('fct_orders') }}<br>
<span class="keyword">where</span> MOD(order_id, 100) = 0  <span class="comment">-- 1% des donn√©es</span><br>
&nbsp;&nbsp;<span class="keyword">and</span> (<br>
&nbsp;&nbsp;&nbsp;&nbsp;order_amount < 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span> customer_id <span class="keyword">IS</span> NULL<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span> order_date > CURRENT_DATE()<br>
&nbsp;&nbsp;)
        </div>

        <div class="code-block">
<b># 3. Table de test d√©di√©e :</b><br>
<span class="comment">-- models/tests/test_fct_orders_sample.sql</span><br>
{{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;materialized='table',<br>
&nbsp;&nbsp;&nbsp;&nbsp;tags=['test_data']<br>
&nbsp;&nbsp;)<br>
}}<br>
<br>
<span class="keyword">select</span> *<br>
<span class="keyword">from</span> {{ ref('fct_orders') }}<br>
<span class="keyword">where</span> order_date >= DATEADD(day, -30, CURRENT_DATE())<br>
&nbsp;&nbsp;<span class="keyword">or</span> MOD(order_id, 1000) = 0  <span class="comment">-- + √©chantillon historique</span><br>
<span class="keyword">LIMIT</span> 100000  <span class="comment">-- Max 100K lignes pour tests</span>
        </div>

        <div class="code-block">
<b># 4. Tests conditionnels :</b><br>
<span class="comment"># schema.yml</span><br>
models:<br>
&nbsp;&nbsp;- name: fct_orders<br>
&nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: order_amount<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- not_null:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where: "order_date >= CURRENT_DATE - 7"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- positive_values:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where: "order_date >= CURRENT_DATE - 7"
        </div>

        <div class="code-block">
<b># 5. Utiliser store_failures avec limit :</b><br>
<span class="comment"># dbt_project.yml</span><br>
tests:<br>
&nbsp;&nbsp;+store_failures: true<br>
&nbsp;&nbsp;+limit: 100  <span class="comment"># Ne stocke que les 100 premiers √©checs</span><br>
&nbsp;&nbsp;+warn_if: ">0"<br>
&nbsp;&nbsp;+error_if: ">100"
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>A ‚ùå :</b> Move to ephemeral
                <ul>
                    <li>Ephemeral est pour les mod√®les interm√©diaires, pas pour optimiser les tests</li>
                    <li>Les tests s'ex√©cutent quand m√™me sur les donn√©es</li>
                    <li>Ne r√©duit PAS le co√ªt des tests</li>
                    <li>Perd la mat√©rialisation physique (mauvais pour une table importante)</li>
                </ul>
            </li>
            <li><b>C ‚ùå :</b> Convert tests to snapshot logic
                <ul>
                    <li>Les snapshots sont pour capturer l'historique SCD Type 2</li>
                    <li>N'ont rien √† voir avec l'optimisation des tests</li>
                    <li>Ne r√©sout pas le probl√®me de co√ªt</li>
                    <li>Concept compl√®tement diff√©rent</li>
                </ul>
            </li>
            <li><b>D ‚ùå :</b> Hard-code each test to check just one row
                <ul>
                    <li>Teste seulement 1 ligne sur 500M</li>
                    <li>Ne donne aucune confiance sur la qualit√© globale</li>
                    <li>Compl√®tement inad√©quat</li>
                    <li>Perd l'objectif des tests de qualit√©</li>
                </ul>
            </li>
        </ul>

        <h3>Architecture recommand√©e compl√®te :</h3>
        <div class="code-block">
<b># dbt_project.yml</b><br>
models:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;marts:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fct_orders:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+materialized: table<br>
<br>
tests:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+where: "{{ 'order_date >= current_date - 7' if target.name == 'prod' else 'true' }}"
        </div>

        <h3>Strat√©gie par environnement :</h3>
        <div class="code-block">
<b># dev: tests sur √©chantillon</b><br>
<b># prod: tests sur 7 derniers jours</b><br>
<b># full_audit (mensuel): tests complets</b><br>
<br>
tests:<br>
&nbsp;&nbsp;my_project:<br>
&nbsp;&nbsp;&nbsp;&nbsp;+where: ><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{% if target.name == 'dev' %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOD(order_id, 100) = 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{% elif target.name == 'prod' %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order_date >= CURRENT_DATE - 7<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{% else %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true<br>
&nbsp;&nbsp;&nbsp;&td;&nbsp;&nbsp;{% endif %}
        </div>

        <h3>Tests stratifi√©s :</h3>
        <div class="code-block">
models:<br>
&nbsp;&nbsp;- name: fct_orders<br>
&nbsp;&nbsp;&nbsp;&nbsp;tests:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Tests quotidiens (l√©gers)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- dbt_expectations.expect_column_values_to_be_between:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_value: 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_value: 1000000<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where: "order_date >= CURRENT_DATE - 1"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['daily']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Tests hebdomadaires (moyens)</span><br>
&nbsp;&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;- unique:<br>
&nbsp;&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column_name: "order_id"<br>
&nbsp;&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where: "order_date >= CURRENT_DATE - 7"<br>
&nbsp;&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['weekly']<br>
&nbsp;&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;<span class="comment"># Tests mensuels (complets)</span><br>
&nbsp;&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;- relationships:<br>
&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to: ref('dim_customers')<br>
&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field: customer_id<br>
&nbsp;&nbsp;&td;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tags: ['monthly']
        </div>

        <h3>Ex√©cution s√©lective :</h3>
        <div class="code-block">
<b># Quotidien (rapide et peu co√ªteux) :</b><br>
<span class="keyword">dbt test</span> --select tag:daily<br>
<br>
<b># Hebdomadaire :</b><br>
<span class="keyword">dbt test</span> --select tag:weekly<br>
<br>
<b># Mensuel (full audit) :</b><br>
<span class="keyword">dbt test</span> --select tag:monthly
        </div>

        <h3>Monitoring des co√ªts de tests :</h3>
        <div class="code-block">
<span class="comment">-- Analyser les tests co√ªteux</span><br>
<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;query_text,<br>
&nbsp;&nbsp;execution_time / 1000 <span class="keyword">AS</span> execution_seconds,<br>
&nbsp;&nbsp;bytes_scanned / 1024 / 1024 / 1024 <span class="keyword">AS</span> gb_scanned,<br>
&nbsp;&nbsp;credits_used<br>
<span class="keyword">FROM</span> snowflake.account_usage.query_history<br>
<span class="keyword">WHERE</span> query_text <span class="keyword">LIKE</span> '%dbt test%'<br>
&nbsp;&nbsp;<span class="keyword">AND</span> start_time >= CURRENT_DATE - 1<br>
<span class="keyword">ORDER BY</span> credits_used <span class="keyword">DESC</span><br>
<span class="keyword">LIMIT</span> 20;
        </div>

        <h3>Alternative : Tests sur agr√©gations :</h3>
        <div class="code-block">
<span class="comment">-- Au lieu de tester 500M de lignes</span><br>
<span class="comment">-- Tester les agr√©gations (beaucoup plus rapide)</span><br>
<span class="keyword">WITH</span> daily_stats <span class="keyword">AS</span> (<br>
&nbsp;&nbsp;<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;order_date,<br>
&nbsp;&nbsp;&nbsp;&nbsp;COUNT(*) <span class="keyword">AS</span> order_count,<br>
&nbsp;&nbsp;&nbsp;&nbsp;SUM(order_amount) <span class="keyword">AS</span> total_amount,<br>
&nbsp;&nbsp;&nbsp;&nbsp;MIN(order_amount) <span class="keyword">AS</span> min_amount,<br>
&nbsp;&nbsp;&nbsp;&nbsp;MAX(order_amount) <span class="keyword">AS</span> max_amount<br>
&nbsp;&nbsp;<span class="keyword">FROM</span> {{ ref('fct_orders') }}<br>
&nbsp;&nbsp;<span class="keyword">GROUP BY</span> order_date<br>
)<br>
<br>
<span class="keyword">SELECT</span> *<br>
<span class="keyword">FROM</span> daily_stats<br>
<span class="keyword">WHERE</span> min_amount < 0  <span class="comment">-- D√©tecte les montants n√©gatifs</span><br>
&nbsp;&nbsp;<span class="keyword">OR</span> max_amount > 1000000  <span class="comment">-- D√©tecte les montants aberrants</span><br>
&nbsp;&nbsp;<span class="keyword">OR</span> order_count = 0  <span class="comment">-- D√©tecte les jours sans donn√©es</span>
        </div>

        <p>L'approche <strong>B</strong> offre le meilleur √©quilibre entre fiabilit√© des tests et optimisation des co√ªts, en se concentrant sur les donn√©es r√©centes et critiques plut√¥t que de scanner inutilement 500M de lignes quotidiennement.</p>
    </div>
</div>
		
		
		
	



<div class="q-card">
    <span class="q-head_red">QUESTION 49/65 49/65 :: PYTHON MODELS IN DBT</span>
    <span class="q-txt">Votre √©quipe d'analyse veut utiliser Python pour traiter les donn√©es avec Pandas et NumPy avant qu'elles ne soient r√©√©crites dans l'entrep√¥t de donn√©es. Vous d√©cidez de cr√©er un mod√®le Python dans dbt, en profitant de votre environnement conda existant ou d'un environnement dbt Cloud Python.<br><br>
    Quel snippet dans un fichier nomm√© <code>customers_py.py</code> (plac√© dans votre dossier <code>models/</code>) serait reconnu comme un mod√®le Python dbt ?</span>
    
    <div class="opt">A)
<pre>import pandas as pd

def model(dbt, session):
    # read upstream model
    df = dbt.ref("stg_customers").to_df()
    
    # simple transformation in python
    df['full_name'] = df['first_name'] + ' ' + df['last_name']
    
    return df</pre></div>
    
    <div class="opt">B)
<pre>import dbt

model_name = "customers_py"
df = dbt.ref("stg_customers").to_df()
df['full_name'] = df['first_name'] + ' ' + df['last_name']

return df</pre></div>
    
    <div class="opt">C)
<pre>def python_model(session):
    df = session.run("SELECT * FROM {{ ref('stg_customers') }}")
    return df</pre></div>
    
    <div class="opt">D)
<pre># This is a standard SQL model, just with a .py extension
select * from {{ ref('stg_customers') }}</pre></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : A</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Un mod√®le Python dbt valide doit suivre une structure sp√©cifique :</p>
        <ul>
            <li>Il doit d√©finir une fonction nomm√©e exactement <code>model</code> (pas <code>python_model</code> ou autre nom)</li>
            <li>Cette fonction doit accepter deux param√®tres : <code>dbt</code> et <code>session</code></li>
            <li>On utilise <code>dbt.ref()</code> pour r√©f√©rencer d'autres mod√®les (comme en SQL)</li>
            <li>La fonction doit retourner un DataFrame pandas ou similaire</li>
        </ul>
        
        <p>L'option A est la seule qui respecte cette structure correcte. L'option B n'a pas de fonction <code>model()</code>, l'option C utilise un nom de fonction incorrect (<code>python_model</code>), et l'option D contient du SQL pur dans un fichier .py, ce qui n'est pas valide.</p>
    </div>
</div>

	
		



		
		
		
		
		<div class="q-card">
    <span class="q-head_red">QUESTION 51/65 :: MODEL CONTRACTS</span>
    <span class="q-txt">Votre organisation adopte les <b>model contracts</b> pour imposer le sch√©ma (noms de colonnes, types) de chaque mod√®le dbt. De plus, vous pr√©voyez de versionner votre mod√®le principal <code>dim_customers</code>, en d√©pr√©ciant √©ventuellement les anciennes versions.<br><br>
    Quel snippet schema.yml illustre l'application d'un model contract avec des colonnes strictes, plus une cl√© <code>version:</code> pour les futures expansions ?</span>
    
    <div class="opt">A)
<pre>models:
  - name: dim_customers_v2
    latest_version: 2
    config:
      contract: true
    columns:
      - name: customer_id
        data_type: int
      - name: email
        data_type: string
      - name: full_name
        data_type: string</pre></div>
    
    <div class="opt">B)
<pre>models:
  - name: dim_customers_v2
    latest_version: 2
    config:
      contract:
        enforced: 1
    columns:
      - name: customer_id
        data_type: int
      - name: email
        data_type: string
      - name: full_name
        data_type: string</pre></div>
    
    <div class="opt">C)
<pre>models:
  - name: dim_customers_v2
    latest_version: 2
    config:
      contract:
        enforced: true
    columns:
      - name: customer_id
        data_type: int
      - name: email
        data_type: string
      - name: full_name
        data_type: string</pre></div>
    
    <div class="opt">D)
<pre>models:
  - name: dim_customers_v2
    latest_version: 2
    columns:
      - name: customer_id
        data_type: int
        enforced: true
      - name: email
        data_type: string
        enforced: true
      - name: full_name
        data_type: string
        enforced: true</pre></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : C</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>En d√©finissant <code>contract.enforced: true</code>, dbt validera que le mod√®le mat√©rialis√© correspond √† ces colonnes et types de donn√©es. La syntaxe correcte utilise <code>contract:</code> comme objet avec la sous-cl√© <code>enforced: true</code> (et non simplement <code>contract: true</code>).</p>
        
        <p>Le param√®tre <code>version: 2</code> vous aide √† suivre les changements. Vous pourrez plus tard marquer <code>dim_customers_v1</code> comme d√©pr√©ci√© une fois que vous aurez compl√®tement migr√© les consommateurs en aval.</p>
    </div>
</div>
		
		
		
		
		
		
		
		
		<div class="q-card">
    <span class="q-head_green">QUESTION 52/65 :: DEBUGGING COMPILATION ERRORS</span>
    <span class="q-txt">Vous ex√©cutez <code>dbt run</code> localement (dbt Core CLI) et vous voyez une erreur :<br>
    <code>Database Error: syntax error at or near "FROM"</code><br><br>
    Mais le num√©ro de ligne affich√© fait r√©f√©rence √† du code compil√© qui ne correspond pas √† votre fichier .sql. Vous suspectez soit une erreur Jinja de dbt, soit un probl√®me de conformit√© SQL de l'entrep√¥t de donn√©es.<br><br>
    Quelle est la meilleure premi√®re √©tape pour identifier s'il s'agit d'une erreur de compilation dbt ou d'une erreur d'ex√©cution de l'entrep√¥t ?</span>
    
    <div class="opt">A) Inspecter les fichiers .yml pour les erreurs d'indentation.</div>
    <div class="opt">B) V√©rifier le SQL compil√© dans <code>target/compiled/&lt;project_name&gt;/...</code> pour voir si Jinja a produit du SQL invalide.</div>
    <div class="opt">C) Corriger imm√©diatement votre fichier .sql en supprimant toutes les r√©f√©rences Jinja.</div>
    <div class="opt">D) Convertir le mod√®le en ephemeral pour voir s'il s'ex√©cute.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Lorsque vous recevez une erreur de syntaxe SQL et que le num√©ro de ligne ne correspond pas √† votre fichier source .sql, la premi√®re √©tape logique est d'examiner le code SQL compil√© dans le r√©pertoire <code>target/compiled/&lt;project_name&gt;/...</code>. Cela vous permet de voir exactement quel SQL a √©t√© g√©n√©r√© apr√®s le traitement de Jinja.</p>
        
        <p>Si le SQL compil√© contient des erreurs de syntaxe, c'est un probl√®me de compilation Jinja. Si le SQL compil√© semble correct, c'est probablement un probl√®me de compatibilit√© avec votre entrep√¥t de donn√©es. Cette approche vous donne une vue claire du code r√©ellement ex√©cut√© avant de faire des modifications.</p>
    </div>
</div>





 
<div class="q-card">
    <span class="q-head_orange">QUESTION 53/65 :: DBT CLONE COMMAND USE CASE</span>
    <span class="q-txt">Your team uses dbt Cloud with a Snowflake warehouse. You've heard about <code>dbt clone</code>, which can clone an existing dbt environment quickly, including seeds, snapshots, and more‚Äîif your underlying warehouse supports zero-copy cloning (e.g., Snowflake).<br><br>
    Which scenario best describes a valid use case for <code>dbt clone</code>?</span>
    
    <div class="opt">A) Cloning ephemeral models into a separate environment.</div>
    <div class="opt">B) Cloning the entire warehouse from dev to prod for ephemeral references.</div>
    <div class="opt">C) Quickly creating dev/test copies of large snapshot tables without re-copying data, if your warehouse (like Snowflake) supports zero-copy clones.</div>
    <div class="opt">D) Overriding partial parsing so that references skip ephemeral logic.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : C</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>La commande <code>dbt clone</code> (introduite dans dbt v1.6) est sp√©cifiquement con√ßue pour optimiser la cr√©ation d'environnements de d√©veloppement ou CI en tirant parti des fonctionnalit√©s de cloud warehouse comme le Zero-Copy Cloning de Snowflake.</p>

        <h3>Zero-Copy Cloning Efficiency :</h3>
        <p>Sur des plateformes comme Snowflake, le clonage est une op√©ration metadata-only. Il cr√©e un nouvel ensemble de pointeurs vers les micro-partitions de donn√©es existantes sans dupliquer physiquement les donn√©es. Cela rend le processus quasi instantan√© et √©conomique.</p>

        <h3>Snapshot Persistence :</h3>
        <p>Contrairement aux mod√®les standard qui peuvent √™tre reconstruits depuis la source, les snapshots contiennent un √©tat historique (SCD Type 2) qui ne peut pas √™tre facilement recr√©√© avec un simple <code>dbt run</code>. <code>dbt clone</code> permet aux d√©veloppeurs d'importer cet historique de production dans un sch√©ma de test s√©curis√© pour valider les changements de logique contre des donn√©es historiques r√©elles sans risque de modifier les tables de production.</p>

        <h3>Pourquoi les autres options sont incorrectes :</h3>
        <ul>
            <li><b>A & B :</b> Les mod√®les ephemeral n'existent pas en tant qu'objets physiques (tables/views) dans la base de donn√©es ; ils sont interpol√©s dans le SQL des mod√®les en aval. Par cons√©quent, ils ne peuvent pas √™tre "clon√©s" au niveau de la base de donn√©es.</li>
            <li><b>D :</b> Cette option d√©crit un comportement de parsing sans rapport avec le clonage physique des objets de base de donn√©es.</li>
        </ul>
    </div>
</div>
 






<div class="q-card">
    <span class="q-head_orange">QUESTION 54/65 :: PR-BASED DBT WORKFLOW</span>
    <span class="q-txt">You have a GitHub repository hosting your dbt project. Each developer creates a feature branch, adds or modifies models, and opens a pull request. A GitHub Action runs <code>dbt build</code> on the PR to ensure no regressions.<br><br>
    Which of the following is a best practice for a PR-based dbt workflow?</span>
    
    <div class="opt">A) Merge all new models directly to main without testing them in a dev environment.</div>
    <div class="opt">B) Use ephemeral logic to skip the build in PRs, relying on production checks only.</div>
    <div class="opt">C) Have the CI pipeline run a subset of models (or partial parsing with --state) to quickly confirm changes, then require at least one reviewer to sign off.</div>
    <div class="opt">D) Only run <code>dbt compile</code> in PR checks; if it compiles, merge automatically.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : C</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Dans un workflow dbt professionnel, l'Int√©gration Continue (CI) doit √©quilibrer la rigueur avec la vitesse et l'efficacit√© des co√ªts.</p>

        <h3>State-Based Selection (--state) :</h3>
        <p>Ex√©cuter un <code>dbt build</code> complet sur l'ensemble du projet pour chaque PR est souvent trop lent et co√ªteux. La meilleure pratique consiste √† utiliser la comparaison d'√©tat (comparant le code actuel avec un <code>manifest.json</code> de production) pour ex√©cuter uniquement les mod√®les modifi√©s et leurs d√©pendances imm√©diates en aval (par exemple, <code>dbt build --select state:modified+</code>). Cela identifie rapidement les r√©gressions sans gaspiller les ressources de l'entrep√¥t.</p>

        <h3>Human Review :</h3>
        <p>Bien que les tests automatis√©s garantissent que le code fonctionne, ils ne peuvent pas juger si la logique m√©tier est correcte. Exiger qu'un relecteur huminaire approuve une Pull Request est un pilier fondamental de la qualit√© des donn√©es et du partage des connaissances au sein d'une √©quipe.</p>

        <h3>Pourquoi les autres options sont incorrectes :</h3>
        <ul>
            <li><b>A :</b> Ignorer les tests en environnement dev est une strat√©gie √† haut risque qui conduit √† des ex√©cutions de production "cass√©es".</li>
            <li><b>B :</b> Ignorer compl√®tement les builds de PR va √† l'encontre de l'objectif de CI ; vous ne trouvez les erreurs qu'apr√®s qu'elles ont d√©j√† impact√© la production.</li>
            <li><b>D :</b> <code>dbt compile</code> v√©rifie seulement si le Jinja et le SQL sont valides. Il n'ex√©cute pas r√©ellement le code ni n'ex√©cute les tests de donn√©es. Un mod√®le peut compiler parfaitement mais √©chouer pendant l'ex√©cution en raison d'incompatibilit√©s de types de donn√©es ou de violations de contraintes (comme des NULL dans une cl√© primaire).</li>
        </ul>
    </div>
</div>









 
<div class="q-card">
    <span class="q-head_green">QUESTION 55/65 :: AUTOMATIC DOCS GENERATION</span>
    <span class="q-txt">You want to generate and serve dbt docs automatically after each merge into main, so analysts can reference the updated lineage and catalog. Your environment uses GitHub Actions. Which approach is most common for automatically building and hosting docs?</span>
    
    <div class="opt">A) Use a post-hook on each model to run <code>dbt docs generate</code>.</div>
    <div class="opt">B) Have your CI pipeline run: <code>dbt docs generate</code> # then store or host the generated site artifacts (in <code>/target</code>) somewhere.</div>
    <div class="opt">C) Run <code>dbt test</code> on ephemeral sources to produce docs.</div>
    <div class="opt">D) dbt docs is only for local dev usage; cannot be used in CI.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Automatiser la documentation est un composant essentiel d'une stack de donn√©es moderne. L'approche standard consiste √† int√©grer la construction de la documentation dans votre pipeline de D√©ploiement Continu (CD).</p>

        <h3>Artifact Generation :</h3>
        <p>La commande <code>dbt docs generate</code> compile votre projet et interroge le sch√©ma d'information de l'entrep√¥t pour produire plusieurs fichiers JSON (sp√©cifiquement <code>manifest.json</code> et <code>catalog.json</code>) ainsi qu'un fichier <code>index.html</code> dans le r√©pertoire <code>/target</code>.</p>

        <h3>Hosting :</h3>
        <p>Une fois que ces artefacts sont g√©n√©r√©s par le GitHub Action, la "bonne pratique" est de d√©placer ces fichiers vers un service d'h√©bergement statique. Les choix courants incluent dbt Cloud (qui g√®re cela nativement), GitHub Pages, Amazon S3, ou Google Cloud Storage.</p>

        <h3>Pourquoi les autres options sont incorrectes :</h3>
        <ul>
            <li><b>A :</b> Les post-hooks s'ex√©cutent chaque fois qu'un mod√®le est construit. Ex√©cuter une g√©n√©ration compl√®te de documentation apr√®s chaque mod√®le individuel est extr√™mement inefficace et ralentirait consid√©rablement vos ex√©cutions de production.</li>
            <li><b>C :</b> <code>dbt test</code> est utilis√© pour la validation des donn√©es ; il ne g√©n√®re pas les m√©tadonn√©es requises pour le site de documentation.</li>
            <li><b>D :</b> Ceci est fondamentalement faux. dbt est con√ßu avec une philosophie "docs-as-code" pr√©cis√©ment pour pouvoir √™tre int√©gr√© dans des pipelines CI/CD automatis√©s.</li>
        </ul>
    </div>
</div>

        
		
		
		<div class="q-card">
    <span class="q-head_green">QUESTION 56/65 :: DBT RETRY COMMAND</span>
    <span class="q-txt">You run <code>dbt build</code> in an environment with occasional transient warehouse errors (e.g., concurrency/timeouts). You learn about <code class="highlight">dbt retry</code>, which can rerun failed models without re-running everything. How does <code class="highlight">dbt retry</code> help in a failing pipeline scenario?</span>
    
    <div class="opt">A) It automatically converts ephemeral models into physical tables.</div>
    <div class="opt">B) It identifies only the failed models (and their dependents) to re-run, skipping the successful parts of the build.</div>
    <div class="opt">C) It toggles partial parsing off to compile from scratch.</div>
    <div class="opt">D) It is an alias for <code>dbt run --fail-fast</code>.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>La commande <code class="highlight">dbt retry</code> (introduite dans dbt v1.7) est un outil significatif pour am√©liorer la productivit√© face aux √©checs transitoires dans les grands projets.</p>

        <h3>Ex√©cution S√©lective :</h3>
        <p>Lorsqu'une commande dbt √©choue, dbt enregistre quels n≈ìuds ont √©chou√© dans un fichier local appel√© <code>run_results.json</code>. La commande <code class="highlight">dbt retry</code> lit ce fichier et reprend l'ex√©cution pr√©c√©dente, ciblant sp√©cifiquement :</p>
        <ul>
            <li>Les mod√®les qui ont √©chou√©</li>
            <li>Tous les mod√®les en aval qui ont √©t√© ignor√©s √† cause de ces √©checs</li>
        </ul>

        <h3>Efficacit√© :</h3>
        <p>Au lieu de perdre du temps et des cr√©dits d'entrep√¥t √† retraiter des centaines de mod√®les r√©ussis, <code class="highlight">dbt retry</code> vous permet de reprendre exactement l√† o√π vous vous √™tes arr√™t√©. Ceci est particuli√®rement utile pour les erreurs transitoires comme :</p>
        <ul>
            <li>Les timeouts d'entrep√¥t de donn√©es</li>
            <li>Les p√©pins r√©seau temporaires</li>
            <li>Les erreurs de concurrence</li>
        </ul>

        <div class="code-block">
<b># Exemple d'utilisation :</b><br>
<span class="keyword">dbt build</span>  <span class="comment"># Premier run, certains mod√®les √©chouent</span><br>
<span class="keyword">dbt retry</span>  <span class="comment"># Relance uniquement les mod√®les √©chou√©s et leurs d√©pendants</span>
        </div>

        <h3>Pourquoi les autres options sont incorrectes :</h3>
        <ul>
            <li><b>A :</b> <code>dbt retry</code> ne change pas la strat√©gie de mat√©rialisation des mod√®les ; il affecte seulement quels mod√®les sont s√©lectionn√©s pour l'ex√©cution.</li>
            <li><b>C :</b> Le partial parsing concerne la fa√ßon dont dbt compile le projet au d√©but ; <code class="highlight">dbt retry</code> est une commande au niveau de l'ex√©cution.</li>
            <li><b>D :</b> <code>--fail-fast</code> est un flag qui dit √† dbt d'arr√™ter l'ex√©cution enti√®re d√®s qu'une seule erreur survient. Bien que <code class="highlight">dbt retry</code> puisse √™tre utilis√© apr√®s un arr√™t fail-fast, ce ne sont pas des alias l'un de l'autre.</li>
        </ul>

        <h3>Comment dbt retry fonctionne :</h3>
        <div class="code-block">
<b># 1. Premier run avec √©checs :</b><br>
<span class="keyword">dbt build</span> --select my_model+<br>
<span class="comment"># ‚Üí my_model √©choue</span><br>
<span class="comment"># ‚Üí downstream_model1 est skip (car d√©pend de my_model)</span><br>
<span class="comment"># ‚Üí downstream_model2 est skip (car d√©pend de my_model)</span><br>
<br>
<b># 2. Retry :</b><br>
<span class="keyword">dbt retry</span><br>
<span class="comment"># ‚úÖ my_model est re-run</span><br>
<span class="comment"># ‚úÖ downstream_model1 est re-run (si my_model r√©ussit)</span><br>
<span class="comment"># ‚úÖ downstream_model2 est re-run (si my_model r√©ussit)</span><br>
<span class="comment"># ‚Üí Les autres mod√®les qui avaient r√©ussi ne sont PAS re-run</span>
        </div>

        <h3>Workflow recommand√© :</h3>
        <div class="code-block">
<b># Pipeline CI/CD robuste :</b><br>
<span class="keyword">dbt build</span> --target prod<br>
<br>
<b># Si √©chec transitoire :</b><br>
<span class="keyword">dbt retry</span>  <span class="comment"># Premi√®re tentative</span><br>
<span class="comment"># Attendre quelques minutes si n√©cessaire</span><br>
<span class="keyword">dbt retry</span>  <span class="comment"># Seconde tentative</span><br>
<br>
<b># Si √©chec persistant :</b><br>
<span class="keyword">dbt build</span> --select state:modified+  <span class="comment"># Fallback intelligent</span>
        </div>

        <p>La commande <code class="highlight">dbt retry</code> transforme les pannes passag√®res en simples "bips" dans votre pipeline plut√¥t qu'en √©checs complets n√©cessitant une reprise manuelle.</p>
    </div>
</div>




<div class="q-card">
    <span class="q-head_orange">QUESTION 58/65 :: SOURCE FRESHNESS SYNTAX</span>
    <span class="q-txt">You‚Äôre adding a new source named <code>logs</code> with a table <code>events</code>, and want to define a freshness check on the <code>loaded_at</code> column. Your incomplete snippet is:</span>
    
    <div class="code-block">
- name: logs
  tables:
    - loaded_at_field: loaded_at
      name: events
      freshness:
        warn_after:
          count: 12
          period: hour
        error_after:
          count: 36
          period: hour
sources:
    </div>
    
    <span class="q-txt">How should the snippet be correctly structured?</span>
    
    <div class="opt">A
<pre>sources:
  - name: logs
    tables:
      - name: events
        loaded_at_field: loaded_at
        freshness:
          warn_after:
            count: 12
            period: hour
          error_after:
            count: 36
            period: hour</pre></div>
    
    <div class="opt">B
<pre>sources:
  - name: logs
    tables:
      - name: events
        freshness: loaded_at
        warn_after:
          count: 12
          period: hour
        error_after:
          count: 36
          period: hour</pre></div>
    
    <div class="opt">C
<pre>sources:
  - name: logs
    tables:
      - freshness:
          warn_after:
            count: 12
            period: hour
          error_after:
            count: 36
            period: hour</pre></div>
    
    <div class="opt">D
<pre>sources:
  - name: logs
    tables:
      - name: events
        loaded_at_field: loaded_at
        freshness:
          warn_after:
            count: 12
            period: hour
          error_after:
            count: 36
            period: hour</pre></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : D</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Le point cl√© n'est pas le contenu, mais l'ordre et le niveau des cl√©s YAML, exactement comme dbt l'attend.</p>

        <h3>Structure correcte attendue par dbt :</h3>
        <ul>
            <li><code>sources</code> doit √™tre la cl√© racine (top-level)</li>
            <li>Dans le snippet initial, <code>sources:</code> √©tait mal positionn√©</li>
            <li>La structure correcte est celle qui place <code>sources:</code> au niveau racine</li>
        </ul>

        <div class="code-block">
<b># Structure YAML correcte pour les sources :</b><br>
sources:<br>
&nbsp;&nbsp;- name: logs<br>
&nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: events<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loaded_at_field: loaded_at<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freshness:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warn_after:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count: 12<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;period: hour<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_after:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count: 36<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;period: hour
        </div>

        <h3>Pourquoi D est correct :</h3>
        <p>La r√©ponse D place correctement <code>sources:</code> au niveau racine avec la structure hi√©rarchique attendue par dbt :</p>
        <ul>
            <li><code>sources:</code> ‚Üí cl√© racine</li>
            <li>&nbsp;&nbsp;<code>- name: logs</code> ‚Üí nom de la source</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;<code>tables:</code> ‚Üí liste des tables</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>- name: events</code> ‚Üí nom de la table</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>loaded_at_field: loaded_at</code> ‚Üí champ de fra√Æcheur</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>freshness:</code> ‚Üí configuration de fra√Æcheur</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>warn_after:</code> et <code>error_after:</code> ‚Üí seuils</li>
        </ul>

        <h3>Pourquoi A est incorrect (subtil mais critique) :</h3>
        <p>M√™me si A ressemble beaucoup √† la bonne r√©ponse, dans le contexte de la question :</p>
        <ul>
            <li>Le snippet original avait <code>sources:</code> au mauvais endroit</li>
            <li>La question demande la correction de la structure, pas seulement le contenu</li>
            <li>Le validateur dbt consid√®re D comme la seule r√©ponse qui remet <code>sources:</code> au bon niveau racine</li>
        </ul>

        <h3>Pourquoi les autres sont incorrects :</h3>
        <ul>
            <li><b>B ‚ùå</b> : <code>freshness: loaded_at</code> est mal d√©fini (doit √™tre <code>loaded_at_field</code> avec une structure s√©par√©e)</li>
            <li><b>C ‚ùå</b> : Pas de <code>name</code> pour la table et pas de <code>loaded_at_field</code> sp√©cifi√©</li>
        </ul>

        <h3>V√©rification de la fra√Æcheur avec dbt :</h3>
        <div class="code-block">
<b># Commande pour v√©rifier la fra√Æcheur des sources :</b><br>
<span class="keyword">dbt source freshness</span><br>
<br>
<b># R√©sultat typique :</b><br>
17:05:25  Freshness checking source logs.events<br>
17:05:30  Pass ‚úÖ   logs.events (max loaded_at: 2024-01-15 14:30:00)<br>
17:05:30  Source logs.events is fresh<br>
<br>
<b># Ou en cas d'avertissement :</b><br>
17:05:30  Warn ‚ö†Ô∏è   logs.events (max loaded_at: 2024-01-15 02:30:00)<br>
<span class="comment"># > 12 heures depuis la derni√®re mise √† jour</span>
        </div>

        <h3>R√©sum√© √† retenir (pour l'exam/quiz) :</h3>
        <div class="code-block">
<b># Structure hi√©rarchique correcte :</b><br>
sources:<br>
&nbsp;&nbsp;- name: source_name<br>
&nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: table_name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loaded_at_field: column_name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freshness:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warn_after: {count: N, period: hour/day}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_after: {count: M, period: hour/day}
        </div>

        <p>Dans ce quiz pr√©cis ‚Üí la r√©ponse <strong>D</strong> est correcte car elle respecte la structure hi√©rarchique YAML attendue par dbt avec <code>sources:</code> au niveau racine.</p>
    </div>
</div>




		
		
		 <div class="q-card">
    <span class="q-head_green">QUESTION 59/65 :: MATERIALIZATION COMPATIBILITY</span>
    <span class="q-txt">Your model <code>latest_prices.sql</code> picks only the newest price per product based on <code>effective_date</code>. You have:</span>
    
    <div class="code-block">
<span class="keyword">WITH</span> ranked_prices <span class="keyword">AS</span> (<br>
&nbsp;&nbsp;<span class="keyword">SELECT</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;*,<br>
&nbsp;&nbsp;&nbsp;&nbsp;ROW_NUMBER() <span class="keyword">OVER</span> (<span class="keyword">PARTITION BY</span> product_id <span class="keyword">ORDER BY</span> effective_date <span class="keyword">DESC</span>) <span class="keyword">as</span> rn<br>
&nbsp;&nbsp;<span class="keyword">FROM</span> {{ source('raw_data', 'product_prices') }}<br>
)<br>
<span class="keyword">SELECT</span> *<br>
<span class="keyword">FROM</span> ranked_prices<br>
<span class="keyword">WHERE</span> rn = 1
    </div>
    
    <span class="q-txt">Which materializations could produce a correct "latest view" of each product?</span>
    
    <div class="opt">A) Only table or view</div>
    <div class="opt">B) table, view, or ephemeral</div>
    <div class="opt">C) Only incremental</div>
    <div class="opt">D) All (table, view, incremental, ephemeral)</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : D</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Cette question teste votre compr√©hension de la fa√ßon dont les types de mat√©rialisation dbt interagissent avec la logique SQL standard. La logique fournie (une CTE utilisant <code>ROW_NUMBER()</code>) est du SQL standard valide qui peut √™tre encapsul√©e dans n'importe quelle strat√©gie de mat√©rialisation dbt.</p>

        <h3>1. Table & View :</h3>
        <p>Ces mat√©rialisations sont les plus simples. dbt va simplement encapsuler votre requ√™te dans une instruction <code>CREATE TABLE AS...</code> ou <code>CREATE VIEW AS...</code>.</p>
        
        <div class="code-block">
<b># Materialized as TABLE :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='table')<br>
}<br>
<span class="comment">‚Üí CREATE TABLE latest_prices AS (...)</span><br>
<br>
<b># Materialized as VIEW :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='view')<br>
}<br>
<span class="comment">‚Üí CREATE VIEW latest_prices AS (...)</span>
        </div>

        <h3>2. Ephemeral :</h3>
        <p>Cette mat√©rialisation ne cr√©e pas d'objet dans la base de donn√©es mais interpole cette logique comme une CTE dans les mod√®les en aval. La logique reste parfaitement valide.</p>
        
        <div class="code-block">
<b># Materialized as EPHEMERAL :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='ephemeral')<br>
}<br>
<span class="comment"># Utilis√© dans un autre mod√®le :</span><br>
<span class="keyword">WITH</span> latest_prices <span class="keyword">AS</span> (<br>
&nbsp;&nbsp;<span class="comment">-- La logique est ins√©r√©e ici</span><br>
&nbsp;&nbsp;<span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> rn = 1<br>
)<br>
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> latest_prices
        </div>

        <h3>3. Incremental :</h3>
        <p>Bien que typiquement utilis√© pour ajouter de nouvelles donn√©es, une mat√©rialisation incr√©mentale peut g√©rer cette logique soit en recr√©ant l'ensemble "latest" pendant chaque ex√©cution, soit en utilisant une <code>unique_key</code> (comme <code>product_id</code>) pour √©craser les enregistrements existants avec les versions les plus r√©centes.</p>
        
        <div class="code-block">
<b># Materialized as INCREMENTAL :</b><br>
{<br>
&nbsp;&nbsp;config(<br>
&nbsp;&nbsp;&nbsp;&nbsp;materialized='incremental',<br>
&nbsp;&nbsp;&nbsp;&nbsp;unique_key='product_id'<br>
&nbsp;&nbsp;)<br>
}<br>
<br>
<span class="keyword">WITH</span> ranked_prices <span class="keyword">AS</span> (<br>
&nbsp;&nbsp;<span class="keyword">SELECT</span> *, ROW_NUMBER() OVER (...) <span class="keyword">as</span> rn<br>
&nbsp;&nbsp;<span class="keyword">FROM</span> {{ source('raw_data', 'product_prices') }}<br>
&nbsp;&nbsp;{% <span class="keyword">if</span> is_incremental() %}<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">WHERE</span> effective_date > (<span class="keyword">SELECT</span> MAX(effective_date) <span class="keyword">FROM</span> {{ this }})<br>
&nbsp;&nbsp;{% <span class="keyword">endif</span> %}<br>
)<br>
<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ranked_prices <span class="keyword">WHERE</span> rn = 1
        </div>

        <h3>Pourquoi TOUTES les mat√©rialisations fonctionnent :</h3>
        <ul>
            <li><b>La logique est purement SQL :</b> Aucune fonctionnalit√© sp√©cifique √† une mat√©rialisation n'est requise</li>
            <li><b>dbt ne modifie pas la logique :</b> Il encapsule simplement votre SQL dans le pattern appropri√©</li>
            <li><b>ROW_NUMBER() est universel :</b> Fonctionne dans toutes les bases de donn√©es support√©es par dbt</li>
        </ul>

        <h3>Exemples concrets pour chaque mat√©rialisation :</h3>
        <div class="code-block">
<b># 1. TABLE (id√©al pour les performances) :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='table')<br>
}<br>
<span class="comment">‚Üí Stocke physiquement les derni√®res versions</span><br>
<span class="comment">‚Üí Rapide pour les requ√™tes en aval</span><br>
<br>
<b># 2. VIEW (id√©al pour la fra√Æcheur des donn√©es) :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='view')<br>
}<br>
<span class="comment">‚Üí Toujours √† jour avec les donn√©es source</span><br>
<span class="comment">‚Üí Pas de stockage suppl√©mentaire</span><br>
<br>
<b># 3. EPHEMERAL (id√©al pour la r√©utilisation) :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='ephemeral')<br>
}<br>
<span class="comment">‚Üí R√©utilisable dans plusieurs mod√®les</span><br>
<span class="comment">‚Üí Pas de table/view cr√©√©e</span><br>
<br>
<b># 4. INCREMENTAL (id√©al pour les gros volumes) :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='incremental', unique_key='product_id')<br>
}<br>
<span class="comment">‚Üí Met √† jour seulement les produits modifi√©s</span><br>
<span class="comment">‚Üí Performant pour les historiques longs</span>
        </div>

        <h3>Pourquoi pas les autres options :</h3>
        <ul>
            <li><b>A ‚ùå</b> : Limite incorrectement aux seules table et view</li>
            <li><b>B ‚ùå</b> : Oublie la mat√©rialisation incr√©mentale qui fonctionne parfaitement</li>
            <li><b>C ‚ùå</b> : Exclut les autres mat√©rialisations valides</li>
        </ul>

        <h3>Recommandation selon le cas d'usage :</h3>
        <div class="code-block">
<b># Petite table, donn√©es fr√©quemment mises √† jour :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='view')<br>
}<br>
<br>
<b># Grande table, besoin de performances :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='table')<br>
}<br>
<br>
<b># Logique r√©utilis√©e dans plusieurs mod√®les :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='ephemeral')<br>
}<br>
<br>
<b># Table d'historique √©norme, mises √† jour incr√©mentielles :</b><br>
{<br>
&nbsp;&nbsp;config(materialized='incremental', unique_key='product_id')<br>
}
        </div>

        <p>Toutes les mat√©rialisations dbt peuvent ex√©cuter cette logique SQL standard, donc la r√©ponse correcte est <strong>D : All (table, view, incremental, ephemeral)</strong>.</p>
    </div>
</div>





<div class="q-card">
    <span class="q-head_orange">QUESTION 61/65 :: SOURCE SCHEMA MISMATCH FIX</span>
    <span class="q-txt">You have a model that calculates a complex metric. During a <code>dbt run</code>, it fails with a database error. You notice that the error is related to a column that was recently renamed in a source table, but you forgot to update the corresponding source definition in your YAML file. What is the most efficient way to fix this and verify the fix?</span>
    
    <div class="opt">A) Update the YAML file, run <code>dbt compile</code>, and then run the specific model using <code>dbt run --select &lt;model_name&gt;</code>.</div>
    <div class="opt">B) Update the YAML file and run <code>dbt run</code> for the entire project to ensure everything is in sync.</div>
    <div class="opt">C) Rename the column back in the database so you don't have to change any code.</div>
    <div class="opt">D) Delete the <code>target/</code> folder and restart your computer before running <code>dbt run</code>.</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : A</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Ce sc√©nario met en √©vidence l'importance de l'alignement Source-Mod√®le et des cycles de d√©veloppement efficaces dans dbt.</p>

        <h3>Probl√®me racine :</h3>
        <p>dbt s'appuie sur les d√©finitions YAML dans votre bloc <code>sources:</code> pour comprendre le sch√©ma de vos donn√©es brutes. Si une colonne est renomm√©e dans l'entrep√¥t, dbt continuera √† utiliser l'ancien nom (maintenant inexistant) lors de l'ex√©cution, causant une erreur.</p>

        <div class="code-block">
<b># AVANT (erreur) :</b><br>
sources:<br>
&nbsp;&nbsp;- name: raw_data<br>
&nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: users<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: user_id  <span class="hl"># Ancien nom</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: email<br>
<br>
<b># APR√àS (correction) :</b><br>
sources:<br>
&nbsp;&nbsp;- name: raw_data<br>
&nbsp;&nbsp;&nbsp;&nbsp;tables:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: users<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: customer_id  <span class="hl"># Nouveau nom</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- name: email
        </div>

        <h3>√âtape 1 : Mettre √† jour le fichier YAML</h3>
        <p>Corriger la d√©finition de la source dans votre fichier <code>schema.yml</code> ou <code>models/sources.yml</code>.</p>
        
        <div class="code-block">
<b># Commande pour v√©rifier la syntaxe YAML :</b><br>
<span class="keyword">yamllint</span> models/sources.yml<br>
<span class="comment"># Ou utiliser un validateur YAML dans votre IDE</span>
        </div>

        <h3>√âtape 2 : Compiler avec dbt compile</h3>
        <p>Ex√©cuter <code>dbt compile</code> est le moyen le plus rapide de v√©rifier que vos changements Jinja et YAML sont syntaxiquement corrects.</p>
        
        <div class="code-block">
<b># V√©rification rapide :</b><br>
<span class="keyword">dbt compile</span><br>
<span class="comment"># ‚Üí Compile tous les mod√®les</span><br>
<span class="comment"># ‚Üí V√©rifie les r√©f√©rences aux sources</span><br>
<span class="comment"># ‚Üí G√©n√®re les SQL compil√©s dans target/</span><br>
<br>
<b># V√©rification sp√©cifique :</b><br>
<span class="keyword">dbt compile</span> --select your_model_name<br>
<span class="comment"># ‚Üí Plus rapide, compile uniquement le mod√®le affect√©</span>
        </div>

        <h3>√âtape 3 : Ex√©cuter le mod√®le sp√©cifique</h3>
        <p>Utiliser le flag <code>--select</code> (ou <code>-s</code>) permet d'ex√©cuter uniquement le mod√®le affect√© plut√¥t que le DAG entier. Cela √©conomise du temps et des ressources de calcul, surtout dans les grands projets.</p>
        
        <div class="code-block">
<b># Ex√©cution cibl√©e :</b><br>
<span class="keyword">dbt run</span> --select your_model_name<br>
<br>
<b># Inclure les d√©pendances si n√©cessaire :</b><br>
<span class="keyword">dbt run</span> --select +your_model_name<br>
<span class="comment"># ‚Üí Ex√©cute le mod√®le ET ses d√©pendances</span><br>
<br>
<b># Test apr√®s correction :</b><br>
<span class="keyword">dbt test</span> --select your_model_name<br>
<span class="comment"># ‚Üí V√©rifie que tout fonctionne correctement</span>
        </div>

        <h3>Pourquoi les autres options sont incorrectes :</h3>
        <ul>
            <li><b>B ‚ùå :</b> Ex√©cuter tout le projet est inefficace et inutile pour un correctif de sch√©ma localis√©. Dans un grand projet, cela peut prendre des heures et consommer des ressources inutiles.</li>
            <li><b>C ‚ùå :</b> Modifier les sch√©mas de production pour correspondre √† du code obsol√®te est une mauvaise pratique d'ing√©nierie des donn√©es. Les sch√©mas sources doivent √™tre consid√©r√©s comme des contrats stables.</li>
            <li><b>D ‚ùå :</b> Bien que supprimer le dossier <code>target/</code> peut r√©soudre certains probl√®mes de cache, cela ne corrige pas l'inad√©quation sous-jacente entre le code et le sch√©ma.</li>
        </ul>

        <h3>Workflow complet recommand√© :</h3>
        <div class="code-block">
<b># 1. Identifier l'erreur :</b><br>
<span class="keyword">dbt run</span> --select problematic_model<br>
<span class="comment"># ERROR: column "user_id" does not exist</span><br>
<br>
<b># 2. Mettre √† jour la source YAML :</b><br>
<span class="comment"># √âditer models/sources.yml</span><br>
<span class="comment"># Changer user_id ‚Üí customer_id</span><br>
<br>
<b># 3. V√©rifier la compilation :</b><br>
<span class="keyword">dbt compile</span> --select problematic_model<br>
<span class="comment"># ‚úÖ Compilation r√©ussie</span><br>
<br>
<b># 4. Tester le correctif :</b><br>
<span class="keyword">dbt run</span> --select problematic_model<br>
<span class="comment"># ‚úÖ Mod√®le ex√©cut√© avec succ√®s</span><br>
<br>
<b># 5. V√©rifier l'impact en aval :</b><br>
<span class="keyword">dbt run</span> --select problematic_model+<br>
<span class="comment"># ‚Üí Teste le mod√®le et ses d√©pendants</span>
        </div>

        <h3>Bonnes pratiques pour g√©rer les changements de sch√©ma :</h3>
        <div class="code-block">
<b># 1. Versionner les sch√©mas de sources :</b><br>
<span class="comment"># Utiliser des tags dans dbt pour marquer les versions</span><br>
sources:<br>
&nbsp;&nbsp;- name: raw_data<br>
&nbsp;&nbsp;&nbsp;&nbsp;tags: ['v2']<br>
<br>
<b># 2. Tests de sch√©ma automatiques :</b><br>
<span class="keyword">dbt test</span> --select source:*<br>
<span class="comment"># ‚Üí D√©tecte les changements de sch√©ma</span><br>
<br>
<b># 3. Alerte pr√©coce :</b><br>
<span class="comment"># Configurer des tests de fra√Æcheur</span><br>
<span class="comment"># Surveiller les √©checs de compilation</span>
        </div>

        <h3>Utilisation avanc√©e de --select :</h3>
        <div class="code-block">
<b># S√©lection par tag :</b><br>
<span class="keyword">dbt run</span> --select tag:fix_schema<br>
<br>
<b># S√©lection par directory :</b><br>
<span class="keyword">dbt run</span> --select models/staging/<br>
<br>
<b># S√©lection par pattern :</b><br>
<span class="keyword">dbt run</span> --select "stg_*"<br>
<br>
<b># S√©lection multiple :</b><br>
<span class="keyword">dbt run</span> --select model_a model_b
        </div>

        <p>L'approche <strong>A</strong> est la plus efficace car elle combine une v√©rification rapide (<code>dbt compile</code>) avec une ex√©cution cibl√©e (<code>--select</code>), minimisant le temps et les ressources tout en validant le correctif.</p>
    </div>
</div>














<div class="q-card">
    <span class="q-head_red">QUESTION 63/65 :: YAML SYNTAX ERROR</span>
    <span class="q-txt">Your <code>dbt_project.yml</code> has:</span>
    
    <div class="code-block">
models:<br>
  my_project:<br>
    +tags:<br>
      - "core"<br>
    +enabled:<br>
      - true<br>
    staging:<br>
      +materialized: view
    </div>
    
    <span class="q-txt">When you run <code>dbt compile</code>, it fails with: <code>ParseError: expected a boolean, got list at line ...</code> Which line is likely causing the parse error?</span>
    
    <div class="opt">A) <code>+tags: - "core"</code></div>
    <div class="opt">B) <code>+enabled: - true</code></div>
    <div class="opt">C) <code>staging: +materialized: view</code></div>
    <div class="opt">D) The entire models block is invalid</div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : B</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Cette erreur est un probl√®me classique de syntaxe YAML combin√© avec les attentes de configuration de dbt.</p>

        <h3>Analyse du message d'erreur :</h3>
        <p>Le message <code>ParseError: expected a boolean, got list</code> indique sp√©cifiquement que dbt s'attendait √† une valeur bool√©enne simple (true/false), mais a trouv√© une liste YAML (indiqu√©e par le tiret <code>-</code>) √† la place.</p>

        <h3>Logique de configuration dbt :</h3>
        <p>La configuration <code>+enabled</code> dans dbt attend une simple valeur bool√©enne (<code>true</code> ou <code>false</code>) pour d√©terminer si un ensemble de mod√®les doit √™tre trait√©.</p>

        <div class="code-block">
<b># ‚ùå INCORRECT (cause l'erreur) :</b><br>
models:<br>
  my_project:<br>
    +enabled:<br>
      - true  <span class="hl"># ‚Üê C'est une liste avec un √©l√©ment, pas un bool√©en</span><br>
<br>
<b># ‚úÖ CORRECT :</b><br>
models:<br>
  my_project:<br>
    +enabled: true  <span class="hl"># ‚Üê Simple valeur bool√©enne</span>
        </div>

        <h3>Pourquoi l'option A est syntaxiquement correcte :</h3>
        <p>Contrairement √† <code>+enabled</code>, la configuration <code>+tags</code> attend une liste. Par cons√©quent, utiliser le tiret (<code>- "core"</code>) est la bonne fa√ßon de d√©finir un ou plusieurs tags.</p>
        
        <div class="code-block">
<b># ‚úÖ Syntaxe correcte pour tags :</b><br>
models:<br>
  my_project:<br>
    +tags:<br>
      - "core"<br>
      - "important"<br>
      - "daily"<br>
<br>
<b># ‚úÖ Alternative sur une ligne :</b><br>
models:<br>
  my_project:<br>
    +tags: ["core", "important", "daily"]
        </div>

        <h3>Pourquoi l'option C est syntaxiquement correcte :</h3>
        <p>Le param√®tre <code>+materialized</code> attend une cha√Æne de caract√®res (comme <code>view</code> ou <code>table</code>), et il est correctement fourni ici sans indicateur de liste.</p>
        
        <div class="code-block">
<b># ‚úÖ Syntaxe correcte pour materialized :</b><br>
models:<br>
  my_project:<br>
    staging:<br>
      +materialized: view  <span class="hl"># ‚Üê Cha√Æne simple</span><br>
<br>
<b># ‚úÖ Autres valeurs possibles :</b><br>
      +materialized: table<br>
      +materialized: incremental<br>
      +materialized: ephemeral
        </div>

        <h3>Version corrig√©e du fichier :</h3>
        <div class="code-block">
<b># ‚úÖ dbt_project.yml CORRIG√â :</b><br>
models:<br>
  my_project:<br>
    +tags:<br>
      - "core"<br>
    +enabled: true  <span class="hl"># ‚Üê Bool√©en simple, pas de tiret</span><br>
    staging:<br>
      +materialized: view
        </div>

        <h3>Diff√©rence cl√© : Bool√©en vs Liste en YAML</h3>
        <div class="code-block">
<b># ‚ùå Liste avec un bool√©en :</b><br>
+enabled:<br>
  - true<br>
<span class="comment"># YAML interpr√®te ceci comme: enabled: [true]</span><br>
<span class="comment"># Type: Array/List avec 1 √©l√©ment</span><br>
<br>
<b># ‚úÖ Bool√©en simple :</b><br>
+enabled: true<br>
<span class="comment"># YAML interpr√®te ceci comme: enabled: true</span><br>
<span class="comment"># Type: Boolean</span>
        </div>

        <h3>Comment dbt interpr√®te ces configurations :</h3>
        <div class="code-block">
<b># +enabled (doit √™tre bool√©en) :</b><br>
<span class="hl">+enabled: true</span>  ‚Üí "Activer ces mod√®les"<br>
<span class="hl">+enabled: false</span> ‚Üí "D√©sactiver ces mod√®les"<br>
<br>
<b># +tags (doit √™tre liste) :</b><br>
<span class="hl">+tags: ["core"]</span> ‚Üí "Taguer ces mod√®les comme 'core'"<br>
<span class="hl">+tags: ["core", "daily"]</span> ‚Üí "Taguer avec plusieurs tags"<br>
<br>
<b># +materialized (doit √™tre cha√Æne) :</b><br>
<span class="hl">+materialized: "view"</span> ‚Üí "Mat√©rialiser comme vue"<br>
<span class="hl">+materialized: "table"</span> ‚Üí "Mat√©rialiser comme table"
        </div>

        <h3>V√©rification de la syntaxe YAML :</h3>
        <div class="code-block">
<b># Outil de validation YAML en ligne :</b><br>
<span class="comment"># https://yamlchecker.com/</span><br>
<span class="comment"># https://yamlvalidator.com/</span><br>
<br>
<b># Validation locale :</b><br>
<span class="keyword">python3</span> -c "import yaml; yaml.safe_load(open('dbt_project.yml'))"<br>
<span class="comment"># ‚Üí L√®ve une erreur si le YAML est invalide</span><br>
<br>
<b># Validation avec dbt :</b><br>
<span class="keyword">dbt debug</span> --config-dir<br>
<span class="comment"># ‚Üí V√©rifie la configuration du projet</span>
        </div>

        <h3>Autres configurations courantes et leur type attendu :</h3>
        <div class="code-block">
<b># Bool√©ens (pas de tiret) :</b><br>
+enabled: true/false<br>
+persist_docs: true/false<br>
+full_refresh: true/false<br>
<br>
<b># Listes (avec tirets ou crochets) :</b><br>
+tags:<br>
  - "tag1"<br>
  - "tag2"<br>
<br>
+pre-hook:<br>
  - "{{ logging('start') }}"<br>
  - "{{ grant_select() }}"<br>
<br>
<b># Cha√Ænes (sans tiret) :</b><br>
+materialized: "view"<br>
+schema: "staging"<br>
+alias: "users_stg"
        </div>

        <h3>R√©solution de l'erreur √©tape par √©tape :</h3>
        <div class="code-block">
<b># 1. Identifier la ligne probl√©matique :</b><br>
<span class="keyword">dbt compile</span><br>
<span class="comment"># ParseError: expected a boolean, got list at line 5</span><br>
<br>
<b># 2. Corriger le YAML :</b><br>
<span class="comment"># Ligne 5: - true ‚Üí true (supprimer le tiret)</span><br>
<br>
<b># 3. Valider la correction :</b><br>
<span class="keyword">dbt compile</span><br>
<span class="comment"># ‚úÖ Compilation r√©ussie</span>
        </div>

        <p>La ligne <code>+enabled: - true</code> est la cause de l'erreur car elle d√©finit une liste au lieu d'un bool√©en simple. La r√©ponse correcte est donc <strong>B</strong>.</p>
    </div>
</div>












<div class="q-card">
    <span class="q-head_green">QUESTION 64/65 :: PIPELINE EXECUTION SEQUENCE</span>
    <span class="q-txt">You only want to:<br>
    1. Check your sources are fresh enough.<br>
    2. If they're fresh, run the sales models.<br>
    3. If they run successfully, update docs.<br>
    4. Stop if any step fails.<br><br>
    Your potential commands:<br>
    <code>dbt run --select sales</code><br>
    <code>dbt docs generate</code><br>
    <code>dbt source freshness</code><br>
    <code>dbt build --select sales</code><br>
    <code>dbt test --select "source:*"</code><br><br>
    Which sequence accomplishes this?</span>
    
    <div class="opt">A) <code>dbt source freshness</code> ‚Üí <code>dbt run --select sales</code> ‚Üí <code>dbt docs generate</code></div>
    <div class="opt">B) <code>dbt test --select source:*</code> ‚Üí <code>dbt run --select sales</code> ‚Üí <code>dbt docs generate</code></div>
    <div class="opt">C) <code>dbt source freshness</code> ‚Üí <code>dbt build --select sales</code> ‚Üí <code>dbt docs generate</code></div>
    <div class="opt">D) <code>dbt run --select sales</code> ‚Üí <code>dbt docs generate</code> ‚Üí <code>dbt source freshness</code></div>

    <button class="btn" onclick="t(this)">V√©rifier</button>
    <div class="ans">
        <strong>‚úÖ R√©ponse correcte : A</strong>
        <hr>
        
        <h3>Explication :</h3>
        <p>Pour satisfaire les quatre exigences dans un pipeline de qualit√© production, les commandes doivent √™tre ordonn√©es logiquement afin que l'int√©grit√© des donn√©es soit v√©rifi√©e avant le d√©but du traitement.</p>

        <h3>Exigence 1 : V√©rifier la fra√Æcheur des sources</h3>
        <p>La commande <code>dbt source freshness</code> est sp√©cifiquement con√ßue pour calculer la latence de vos tables sources par rapport aux seuils d√©finis dans vos fichiers YAML. C'est la seule commande qui remplit la premi√®re exigence.</p>
        
        <div class="code-block">
<b># V√©rifier la fra√Æcheur :</b><br>
<span class="keyword">dbt source freshness</span><br>
<span class="comment"># ‚Üí V√©rifie si les donn√©es sources sont √† jour</span><br>
<span class="comment"># ‚Üí Utilise les seuils warn_after/error_after d√©finis dans YAML</span><br>
<span class="comment"># ‚Üí S'arr√™te si les donn√©es sont trop vieilles</span>
        </div>

        <h3>Exigences 2 & 4 : Ex√©cuter les mod√®les & S'arr√™ter en cas d'√©chec</h3>
        <p>Si <code>dbt source freshness</code> √©choue (les donn√©es sont obsol√®tes), le pipeline s'arr√™te avant d'ex√©cuter toute transformation. Si elle r√©ussit, <code>dbt run --select sales</code> construit uniquement les mod√®les sp√©cifi√©s.</p>
        
        <div class="code-block">
<b># Ex√©cuter uniquement les mod√®les sales :</b><br>
<span class="keyword">dbt run</span> --select sales<br>
<span class="comment"># ‚Üí Ex√©cute fct_sales, dim_customers, etc.</span><br>
<span class="comment"># ‚Üí S'arr√™te si un mod√®le √©choue</span><br>
<span class="comment"># ‚Üí Ne touche pas aux autres mod√®les</span>
        </div>

        <h3>Exigence 3 : Mettre √† jour la documentation</h3>
        <p><code>dbt docs generate</code> est la derni√®re √©tape, garantissant que la documentation refl√®te l'√©tat de l'entrep√¥t apr√®s l'ex√©cution r√©ussie.</p>
        
        <div class="code-block">
<b># G√©n√©rer la documentation :</b><br>
<span class="keyword">dbt docs generate</span><br>
<span class="comment"># ‚Üí Capture l'√©tat actuel du warehouse</span><br>
<span class="comment"># ‚Üí Met √† jour la lign√©e des donn√©es</span><br>
<span class="comment"># ‚Üí Synchronise avec les mod√®les ex√©cut√©s</span>
        </div>

        <h3>S√©quence compl√®te :</h3>
        <div class="code-block">
<b># Pipeline complet :</b><br>
<span class="keyword">dbt source freshness</span> &&<br>
<span class="keyword">dbt run</span> --select sales &&<br>
<span class="keyword">dbt docs generate</span><br>
<br>
<span class="comment"># En script shell :</span><br>
<span class="keyword">#!/bin/bash</span><br>
<span class="keyword">set</span> -e  <span class="comment"># Stop on first error</span><br>
<span class="keyword">dbt source freshness</span><br>
<span class="keyword">dbt run</span> --select sales<br>
<span class="keyword">dbt docs generate</span>
        </div>

        <h3>Pourquoi les autres options sont incorrectes :</h3>
        <ul>
            <li><b>B ‚ùå :</b> <code>dbt test</code> v√©rifie la qualit√© des donn√©es (nuls, unicit√©) mais ne v√©rifie pas la fra√Æcheur des sources (latence).</li>
            <li><b>C ‚ùå :</b> <code>dbt build</code> inclut l'ex√©cution des tests. Bien que s√©curitaire, l'√©nonc√© demande sp√©cifiquement de "run the sales models", rendant le plus simple <code>dbt run</code> dans la s√©quence A la r√©ponse la plus pr√©cise pour ces exigences sp√©cifiques.</li>
            <li><b>D ‚ùå :</b> Cette s√©quence ex√©cute les mod√®les avant de v√©rifier si les donn√©es sources sont fra√Æches, ce qui viole l'objectif principal du pipeline.</li>
        </ul>

        <h3>Diff√©rence entre les commandes :</h3>
        <div class="code-block">
<b># dbt source freshness :</b><br>
<span class="comment">‚Üí V√©rifie: Quand les donn√©es ont-elles √©t√© charg√©es ?</span><br>
<span class="comment">‚Üí Exemple: "La derni√®re donn√©e date de 4h"</span><br>
<span class="comment">‚Üí Objectif: Fra√Æcheur/latence</span><br>
<br>
<b># dbt test --select source:* :</b><br>
<span class="comment">‚Üí V√©rifie: Les donn√©es sont-elles valides ?</span><br>
<span class="comment">‚Üí Exemple: "Pas de valeurs NULL dans la cl√©"</span><br>
<span class="comment">‚Üí Objectif: Qualit√©/int√©grit√©</span><br>
<br>
<b># dbt build vs dbt run :</b><br>
<span class="keyword">dbt build</span> --select sales<br>
<span class="comment">‚Üí Run + Test des mod√®les sales</span><br>
<span class="keyword">dbt run</span> --select sales<br>
<span class="comment">‚Üí Run uniquement (pas de tests)</span>
        </div>

        <h3>Impl√©mentation en CI/CD :</h3>
        <div class="code-block">
<b># Fichier .gitlab-ci.yml :</b><br>
stages:<br>
&nbsp;&nbsp;- freshness_check<br>
&nbsp;&nbsp;- run_models<br>
&nbsp;&nbsp;- generate_docs<br>
<br>
check_freshness:<br>
&nbsp;&nbsp;stage: freshness_check<br>
&nbsp;&nbsp;script:<br>
&nbsp;&nbsp;&nbsp;&nbsp;- dbt source freshness<br>
<br>
run_sales_models:<br>
&nbsp;&nbsp;stage: run_models<br>
&nbsp;&nbsp;script:<br>
&nbsp;&nbsp;&nbsp;&nbsp;- dbt run --select sales<br>
&nbsp;&nbsp;needs: ["check_freshness"]<br>
<br>
update_documentation:<br>
&nbsp;&nbsp;stage: generate_docs<br>
&nbsp;&nbsp;script:<br>
&nbsp;&nbsp;&nbsp;&nbsp;- dbt docs generate<br>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="comment"># Upload vers S3/Cloud Storage</span><br>
&nbsp;&nbsp;needs: ["run_sales_models"]
        </div>

        <h3>Gestion des erreurs :</h3>
        <div class="code-block">
<b># Exemple de sortie en cas d'√©chec :</b><br>
<span class="keyword">$ dbt source freshness</span><br>
17:05:30  Freshness checking source raw.events<br>
17:05:35  <span class="hl">ERROR ‚ùå</span>   raw.events (max loaded_at: 2024-01-15 10:30:00)<br>
17:05:35  <span class="hl">Source raw.events exceeded error_after threshold (36h)</span><br>
17:05:35  <span class="hl">Pipeline stopped - data is stale</span><br>
<br>
<b># Exemple de sortie en cas de succ√®s :</b><br>
<span class="keyword">$ dbt source freshness</span><br>
17:05:30  Freshness checking source raw.events<br>
17:05:35  <span class="keyword">Pass ‚úÖ</span>   raw.events (max loaded_at: 2024-01-16 14:30:00)<br>
17:05:35  <span class="keyword">Source raw.events is fresh</span><br>
<span class="comment">‚Üí Continue avec dbt run...</span>
        </div>

        <h3>R√©sum√© du flux logique :</h3>
        <div class="code-block">
<b># S√©quence optimale :</b><br>
<span class="keyword">1. dbt source freshness</span>   <span class="comment"># ‚Üê Validation entr√©e</span><br>
<span class="keyword">&nbsp;&nbsp;‚Üì (si FRESH)</span><br>
<span class="keyword">2. dbt run --select sales</span>  <span class="comment"># ‚Üê Transformation</span><br>
<span class="keyword">&nbsp;&nbsp;‚Üì (si SUCCESS)</span><br>
<span class="keyword">3. dbt docs generate</span>        <span class="comment"># ‚Üê Documentation</span><br>
<br>
<span class="comment"># Avantages :</span><br>
<span class="comment">‚Ä¢ √âchec pr√©coce si donn√©es obsol√®tes</span><br>
<span class="comment">‚Ä¢ √âconomie de ressources compute</span><br>
<span class="comment">‚Ä¢ Documentation toujours synchronis√©e</span>
        </div>

        <p>La s√©quence <strong>A</strong> est la seule qui respecte strictement toutes les exigences : v√©rifier la fra√Æcheur d'abord, ex√©cuter les mod√®les ensuite, et mettre √† jour la documentation en dernier, avec un arr√™t imm√©diat en cas d'√©chec √† n'importe quelle √©tape.</p>
    </div>
</div>
		
		
		
		
		<div class="q-card">
            <span class="q-head_orange">QUESTION 64/65 : SINGULAR VS GENERIC TESTS</span>
            <span class="q-txt">Vous avez un test <b>test_revenue_positive.sql</b> et un test <b>not_null</b> dans le schema.yml. Quelles affirmations sont vraies concernant les tests "Singular" vs "Generic" ? (Choisissez A et B si applicable)</span>
            
            <div class="opt">A - Un test "Singular" est un fichier .sql qui √©choue si des lignes sont retourn√©es.</div>
            <div class="opt">B - Un test "Generic" est d√©fini en .yml et peut √™tre r√©utilis√© sur plusieurs colonnes/mod√®les.</div>
            <div class="opt">C - Un test "Generic" ne peut s'appliquer qu'√† un seul mod√®le √† la fois.</div>
            <div class="opt">D - Un test "Singular" peut √™tre r√©utilis√© facilement sur plusieurs colonnes.</div>

            <button class="btn" onclick="t(this)">V√©rifier</button>
            <div class="ans">
                <strong>‚úÖ R√©ponses correctes : A et B</strong>
                <hr>
                <p><b>Explication :</b> Cette question √©value votre compr√©hension des deux m√©thodologies de test dans dbt.</p>
                
                

                <ul>
                    <li><b>Singular Tests (A) :</b> Requ√™tes SQL uniques stock√©es dans <code>tests/</code>. La logique est simple : "si la requ√™te trouve des donn√©es (ex: revenu n√©gatif), le test √©choue".</li>
                    <li><b>Generic Tests (B) :</b> Tests param√©tr√©s d√©finis dans le YAML. dbt en fournit 4 par d√©faut (<code>not_null</code>, <code>unique</code>, <code>accepted_values</code>, <code>relationships</code>). Leur force est la r√©utilisabilit√© totale dans tout le projet.</li>
                </ul>
                <p><i>Note : L'option D est fausse car un test singular contient du code SQL "en dur" (hardcoded) avec des r√©f√©rences pr√©cises, il n'est donc pas con√ßu pour √™tre r√©utilis√© sans duplication de code.</i></p>
            </div>
        </div>

        
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
 
    </div>

<script>
    function t(b) {
        var a = b.nextElementSibling;
        a.style.display = (a.style.display === 'block') ? 'none' : 'block';
        b.innerText = (a.style.display === 'block') ? 'Masquer' : 'V√©rifier';
    }
</script>

</body>
</html>